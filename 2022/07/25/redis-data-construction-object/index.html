<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>redis_data_construction_object | Hexo</title><meta name="author" content="John Doe"><meta name="copyright" content="John Doe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SDS  简单动态字符串(simple dynamic string, SDS) 优点：  常数级复杂度获取字符串长度 杜绝缓冲区溢出 减少修改字符串长度时所需的内存重分配次数 二进制安全和保存二进制数据 兼容部分C字符串函数  为什么Redis没有直接使用C语言传统的字符串表示，而是自己构建SDS，并作为Redis的默认字符串表示？SDS 的定义每个sds.h &#x2F; sdshr 结构表示">
<meta property="og:type" content="article">
<meta property="og:title" content="redis_data_construction_object">
<meta property="og:url" content="http://example.com/2022/07/25/redis-data-construction-object/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="SDS  简单动态字符串(simple dynamic string, SDS) 优点：  常数级复杂度获取字符串长度 杜绝缓冲区溢出 减少修改字符串长度时所需的内存重分配次数 二进制安全和保存二进制数据 兼容部分C字符串函数  为什么Redis没有直接使用C语言传统的字符串表示，而是自己构建SDS，并作为Redis的默认字符串表示？SDS 的定义每个sds.h &#x2F; sdshr 结构表示">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2022-07-25T10:22:48.000Z">
<meta property="article:modified_time" content="2022-07-25T10:25:01.028Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/07/25/redis-data-construction-object/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'redis_data_construction_object',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-25 18:25:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Hexo</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">redis_data_construction_object</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-07-25T10:22:48.000Z" title="Created 2022-07-25 18:22:48">2022-07-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-07-25T10:25:01.028Z" title="Updated 2022-07-25 18:25:01">2022-07-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redis_data_construction_object"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="SDS-简单动态字符串"><a href="#SDS-简单动态字符串" class="headerlink" title="SDS  简单动态字符串"></a>SDS  简单动态字符串</h1><p>(simple dynamic string, SDS)</p>
<p>优点：</p>
<ul>
<li>常数级复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串长度时所需的内存重分配次数</li>
<li>二进制安全和保存二进制数据</li>
<li>兼容部分C字符串函数</li>
</ul>
<h2 id="为什么Redis没有直接使用C语言传统的字符串表示，而是自己构建SDS，并作为Redis的默认字符串表示？"><a href="#为什么Redis没有直接使用C语言传统的字符串表示，而是自己构建SDS，并作为Redis的默认字符串表示？" class="headerlink" title="为什么Redis没有直接使用C语言传统的字符串表示，而是自己构建SDS，并作为Redis的默认字符串表示？"></a>为什么Redis没有直接使用C语言传统的字符串表示，而是自己构建SDS，并作为Redis的默认字符串表示？</h2><h2 id="SDS-的定义"><a href="#SDS-的定义" class="headerlink" title="SDS 的定义"></a>SDS 的定义</h2><p>每个sds.h &#x2F; sdshr 结构表示一个SDS值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="type">int</span> len ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>SDS示例1：</p>
<p>![image-20220725151505876](redis 数据结构对象.assets&#x2F;image-20220725151505876.png)</p>
<ul>
<li>free 属性值为0，表示这个SDS没有分配任何未使用空间</li>
<li>len 属性值为5，表示这个SDS保存了一个5字节长的字符串</li>
<li>buf 属性 是一个char的字节数组，数组的前五个字节分别保存了’R’ ,’e’ ,’d’,’i’, ‘s’, 最后一个字节则保存了空字符 ‘\0’</li>
<li>SDS遵循C字符串以空字符串结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且添加额外的1字节空间以及向字符串末尾添加空字符都是由SDS函数自动完成</li>
</ul>
<p>SDS示例2——带有未使用空间：</p>
<p>![image-20220725151704556](redis 数据结构对象.assets&#x2F;image-20220725151704556.png)</p>
<ul>
<li><p>free 属性值为5，表示这个SDS有分配有5个未使用空间</p>
</li>
<li><p>len 属性值为5，表示这个SDS保存了一个5字节长的字符串</p>
</li>
</ul>
<h2 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h2><h3 id="1-常数复杂度获取字符串长度"><a href="#1-常数复杂度获取字符串长度" class="headerlink" title="1. 常数复杂度获取字符串长度"></a>1. 常数复杂度获取字符串长度</h3><p>因为C字符串 并不记录自身的长度信息，所有为了获取一个C字符串的长度，程序必须遍历整个字符串，这个操作的时间复杂度为O(N)</p>
<p>而SDS 在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度为O(1)</p>
<h3 id="2-杜绝缓冲区溢出"><a href="#2-杜绝缓冲区溢出" class="headerlink" title="2. 杜绝缓冲区溢出"></a>2. 杜绝缓冲区溢出</h3><p>因为C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出（buffer overflow) 。</p>
<p>而SDS 的空间分配策略完全杜绝了发送缓冲区溢出的可能性：当SDS的API需要对SDS进行修改时，API 会检查SDS空间是否满足要求，如果不满足，则自动扩展空间到修改所需的大小，然后执行相关操作。即SDS可以 自动修改SDS空间大小，不存在缓冲区溢出问题。</p>
<h3 id="3-减少修改字符串时带来的内存重分配次数"><a href="#3-减少修改字符串时带来的内存重分配次数" class="headerlink" title="3. 减少修改字符串时带来的内存重分配次数"></a>3. 减少修改字符串时带来的内存重分配次数</h3><p>因为C字符串的底层实现总是一个n + 1 个字符串的数组（额外的一个字符空间用来保存空字符），内存重分配容易导致：缓冲区溢出和内存泄露问题</p>
<p>而SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联，在SDS中，buf数组的长度不一定就是字符数量+1，数组里面可以包含未使用的字节，其中字节数量就是free属性。</p>
<p>通过未使用空间，SDS实现了空间预分配和惰性空间释放两种优化策略。</p>
<h4 id="1）空间预分配"><a href="#1）空间预分配" class="headerlink" title="1）空间预分配"></a>1）空间预分配</h4><p> 用于优化SDS的字符串增长操作：当SDS的API对一个SDS操作时，并进行空间扩展，程序不仅会提供所需修改空间，还会为SDS分配额外的未使用空间。</p>
<p>分为两种情况讨论空间数量分配：</p>
<ul>
<li><p>对SDS进行修改之后，SDS的长度（len) <strong>小于</strong>1 MB , 那么程序分配和len属性相同的未使用空间。</p>
<p>例子：修改后，SDS的len变成13字节，那么程序也分配<strong>13字节</strong>给未使用空间，SDS的buf数组的实际长度为13+13+1 &#x3D; 27字节（额外1字节保存空字符）</p>
</li>
<li><p>对SDS进行修改之后，SDS的长度（len) <strong>大于</strong>1 MB， 那么程序会分配1MB的未使用空间。</p>
<p>例子：修改后，SDS的len变成30MB字节，那么程序分配<strong>1MB</strong>给未使用空间，SDS的buf数组的实际长度为30MB + 1MB + 1byte</p>
</li>
</ul>
<p>因此：通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。</p>
<h4 id="2）惰性空间释放"><a href="#2）惰性空间释放" class="headerlink" title="2）惰性空间释放"></a>2）惰性空间释放</h4><p>用于优化SDS的字符串缩短操作：当SDS需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用。</p>
<p>因此：通过惰性空间释放策略，SDS避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化，避免了内存浪费。</p>
<h3 id="4-二进制安全"><a href="#4-二进制安全" class="headerlink" title="4. 二进制安全"></a>4. 二进制安全</h3><p>因为 C字符串中必须符合某种编码（如ASCII) ，并且除了字符串的末尾之外，字符串里面不能包含字符，否则最先被程序读入的空字符会被误认为是字符串的结尾，因此C字符串只能保存文本数据。</p>
<p>而Redis为了可以适用于各种不同的使用场景，SDS的API都是二进制安全的，所有SDS 的API都会以处理二进制的方式来处理存放buf数组的数据。因此我们将SDS的buf属性也被称为字节数组的原因。</p>
<p>Redis不是用这个数组来保存字符，而是用它来保存一系列的二进制数据。</p>
<h3 id="5-兼容部分C字符串函数"><a href="#5-兼容部分C字符串函数" class="headerlink" title="5. 兼容部分C字符串函数"></a>5. 兼容部分C字符串函数</h3><p>保存文本数据的SDS可以重用一部分<code>&lt;string.h&gt;</code>库定义的函数</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>两者的区别</p>
<table>
<thead>
<tr>
<th>C字符串</th>
<th>SDS</th>
</tr>
</thead>
<tbody><tr>
<td>获取字符串长度的复杂度为O(N)</td>
<td>获取字符串长度的复杂度为O(1)</td>
</tr>
<tr>
<td>API非安全的，<strong>可能</strong>造成缓冲区溢出</td>
<td>API是安全的，<strong>不会</strong>造成缓冲区溢出</td>
</tr>
<tr>
<td>修改字符串长度N次必然需要执行N次内存重分配</td>
<td>修改字符串长度N次最多需要执行N次内存重分配</td>
</tr>
<tr>
<td>只能保存文本数据</td>
<td>可以保存文本或者二进制数据</td>
</tr>
<tr>
<td>可以使用所有&lt;string.h&gt;库中的函数</td>
<td>可以使用一部分&lt;string.h&gt;库中的函数</td>
</tr>
</tbody></table>
<h2 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>sdsnew</code></td>
<td>创建一个包含给定 C 字符串的 SDS 。</td>
<td>O(N) ， <code>N</code> 为给定 C 字符串的长度。</td>
</tr>
<tr>
<td><code>sdsempty</code></td>
<td>创建一个不包含任何内容的空 SDS 。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>sdsfree</code></td>
<td>释放给定的 SDS 。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>sdslen</code></td>
<td>返回 SDS 的已使用空间字节数。</td>
<td>这个值可以通过读取 SDS 的 <code>len</code> 属性来直接获得， 复杂度为 O(1) 。</td>
</tr>
<tr>
<td><code>sdsavail</code></td>
<td>返回 SDS 的未使用空间字节数。</td>
<td>这个值可以通过读取 SDS 的 <code>free</code> 属性来直接获得， 复杂度为 O(1) 。</td>
</tr>
<tr>
<td><code>sdsdup</code></td>
<td>创建一个给定 SDS 的副本（copy）。</td>
<td>O(N) ， <code>N</code> 为给定 SDS 的长度。</td>
</tr>
<tr>
<td><code>sdsclear</code></td>
<td>清空 SDS 保存的字符串内容。</td>
<td>因为惰性空间释放策略，复杂度为 O(1) 。</td>
</tr>
<tr>
<td><code>sdscat</code></td>
<td>将给定 C 字符串拼接到 SDS 字符串的末尾。</td>
<td>O(N) ， <code>N</code> 为被拼接 C 字符串的长度。</td>
</tr>
<tr>
<td><code>sdscatsds</code></td>
<td>将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾。</td>
<td>O(N) ， <code>N</code> 为被拼接 SDS 字符串的长度。</td>
</tr>
<tr>
<td><code>sdscpy</code></td>
<td>将给定的 C 字符串复制到 SDS 里面， 覆盖 SDS 原有的字符串。</td>
<td>O(N) ， <code>N</code> 为被复制 C 字符串的长度。</td>
</tr>
<tr>
<td><code>sdsgrowzero</code></td>
<td>用空字符将 SDS 扩展至给定长度。</td>
<td>O(N) ， <code>N</code> 为扩展新增的字节数。</td>
</tr>
<tr>
<td><code>sdsrange</code></td>
<td>保留 SDS 给定区间内的数据， 不在区间内的数据会被覆盖或清除。</td>
<td>O(N) ， <code>N</code> 为被保留数据的字节数。</td>
</tr>
<tr>
<td><code>sdstrim</code></td>
<td>接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。</td>
<td>O(M*N) ， <code>M</code> 为 SDS 的长度， <code>N</code> 为给定 C 字符串的长度。</td>
</tr>
<tr>
<td><code>sdscmp</code></td>
<td>对比两个 SDS 字符串是否相同。</td>
<td>O(N) ， <code>N</code> 为两个 SDS 中较短的那个 SDS 的长度。</td>
</tr>
</tbody></table>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>因为Redis使用的C语言并没有内置这种数据结构，所以Redis构建了自己的链表实现。</p>
<ul>
<li>链表被广泛用于实现 Redis 的各种功能， 比如<strong>列表键， 发布与订阅， 慢查询， 监视器，</strong> 等等。</li>
<li>每个链表节点由一个 <code>listNode</code> 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 <strong>Redis 的链表实现是双端链表。</strong></li>
<li>每个链表使用一个 <code>list</code> 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。</li>
<li>因为链表表头节点的前置节点和表尾节点的后置节点都指向 <code>NULL</code> ， 所以 <strong>Redis 的链表实现是无环链表</strong>。</li>
<li>通过为链表设置不同的类型特定函数， <strong>Redis 的链表可以用于保存各种不同类型的值</strong>。</li>
</ul>
<h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><p>每个链表节点使用一个 <code>adlist.h/listNode</code> 结构来表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>





<p>多个 <code>listNode</code> 可以通过 <code>prev</code> 和 <code>next</code> 指针组成双端链表， 如图 3-1 所示。</p>
<p>![3](redis 数据结构对象.assets&#x2F;3.png)</p>
<p>虽然仅仅使用多个 <code>listNode</code> 结构就可以组成链表， 但使用 <code>adlist.h/list</code> 来持有链表的话， 操作起来会更方便：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>



<p><code>list</code> 结构为链表提供了表头指针 <code>head</code> 、表尾指针 <code>tail</code> ， 以及链表长度计数器 <code>len</code> ， 而 <code>dup</code> 、 <code>free</code> 和 <code>match</code> 成员则是用于实现多态链表所需的类型特定函数：</p>
<ul>
<li><code>dup</code> 函数用于复制链表节点所保存的值；</li>
<li><code>free</code> 函数用于释放链表节点所保存的值；</li>
<li><code>match</code> 函数则用于对比链表节点所保存的值和另一个输入值是否相等。</li>
</ul>
<p>![4](redis 数据结构对象.assets&#x2F;4.png)</p>
<p>Redis 的链表实现的特性可以总结如下：</p>
<ul>
<li>双端： 链表节点带有 <code>prev</code> 和 <code>next</code> 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。</li>
<li>无环： 表头节点的 <code>prev</code> 指针和表尾节点的 <code>next</code> 指针都指向 <code>NULL</code> ， 对链表的访问以 <code>NULL</code> 为终点。</li>
<li>带表头指针和表尾指针： 通过 <code>list</code> 结构的 <code>head</code> 指针和 <code>tail</code> 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。</li>
<li>带链表长度计数器： 程序使用 <code>list</code> 结构的 <code>len</code> 属性来对 <code>list</code> 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1) 。</li>
<li>多态： 链表节点使用 <code>void*</code> 指针来保存节点值， 并且可以通过 <code>list</code> 结构的 <code>dup</code> 、 <code>free</code> 、 <code>match</code> 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。</li>
</ul>
<h2 id="链表和链表节点的API"><a href="#链表和链表节点的API" class="headerlink" title="链表和链表节点的API"></a>链表和链表节点的API</h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>listSetDupMethod</code></td>
<td>将给定的函数设置为链表的节点值复制函数。</td>
<td>O(1) 。</td>
</tr>
<tr>
<td><code>listGetDupMethod</code></td>
<td>返回链表当前正在使用的节点值复制函数。</td>
<td>复制函数可以通过链表的 <code>dup</code> 属性直接获得， O(1)</td>
</tr>
<tr>
<td><code>listSetFreeMethod</code></td>
<td>将给定的函数设置为链表的节点值释放函数。</td>
<td>O(1) 。</td>
</tr>
<tr>
<td><code>listGetFree</code></td>
<td>返回链表当前正在使用的节点值释放函数。</td>
<td>释放函数可以通过链表的 <code>free</code> 属性直接获得， O(1)</td>
</tr>
<tr>
<td><code>listSetMatchMethod</code></td>
<td>将给定的函数设置为链表的节点值对比函数。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>listGetMatchMethod</code></td>
<td>返回链表当前正在使用的节点值对比函数。</td>
<td>对比函数可以通过链表的 <code>match</code> 属性直接获得， O(1)</td>
</tr>
<tr>
<td><code>listLength</code></td>
<td>返回链表的长度（包含了多少个节点）。</td>
<td>链表长度可以通过链表的 <code>len</code> 属性直接获得， O(1) 。</td>
</tr>
<tr>
<td><code>listFirst</code></td>
<td>返回链表的表头节点。</td>
<td>表头节点可以通过链表的 <code>head</code> 属性直接获得， O(1) 。</td>
</tr>
<tr>
<td><code>listLast</code></td>
<td>返回链表的表尾节点。</td>
<td>表尾节点可以通过链表的 <code>tail</code> 属性直接获得， O(1) 。</td>
</tr>
<tr>
<td><code>listPrevNode</code></td>
<td>返回给定节点的前置节点。</td>
<td>前置节点可以通过节点的 <code>prev</code> 属性直接获得， O(1) 。</td>
</tr>
<tr>
<td><code>listNextNode</code></td>
<td>返回给定节点的后置节点。</td>
<td>后置节点可以通过节点的 <code>next</code> 属性直接获得， O(1) 。</td>
</tr>
<tr>
<td><code>listNodeValue</code></td>
<td>返回给定节点目前正在保存的值。</td>
<td>节点值可以通过节点的 <code>value</code> 属性直接获得， O(1) 。</td>
</tr>
<tr>
<td><code>listCreate</code></td>
<td>创建一个不包含任何节点的新链表。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>listAddNodeHead</code></td>
<td>将一个包含给定值的新节点添加到给定链表的表头。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>listAddNodeTail</code></td>
<td>将一个包含给定值的新节点添加到给定链表的表尾。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>listInsertNode</code></td>
<td>将一个包含给定值的新节点添加到给定节点的之前或者之后。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>listSearchKey</code></td>
<td>查找并返回链表中包含给定值的节点。</td>
<td>O(N) ， <code>N</code> 为链表长度。</td>
</tr>
<tr>
<td><code>listIndex</code></td>
<td>返回链表在给定索引上的节点。</td>
<td>O(N) ， <code>N</code> 为链表长度。</td>
</tr>
<tr>
<td><code>listDelNode</code></td>
<td>从链表中删除给定节点。</td>
<td>O(1) 。</td>
</tr>
<tr>
<td><code>listRotate</code></td>
<td>将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头， 成为新的表头节点。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>listDup</code></td>
<td>复制一个给定链表的副本。</td>
<td>O(N) ， <code>N</code> 为链表长度。</td>
</tr>
<tr>
<td><code>listRelease</code></td>
<td>释放给定链表，以及链表中的所有节点。</td>
<td>O(N) ， <code>N</code> 为链表长度。</td>
</tr>
</tbody></table>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>Redis 的字典使用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。</p>
<h2 id="哈希表定义"><a href="#哈希表定义" class="headerlink" title="哈希表定义"></a>哈希表定义</h2><p>Redis 字典所使用的哈希表由 <code>dict.h/dictht</code> 结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line"></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>



<p><code>table</code> 属性是一个数组， 数组中的每个元素都是一个指向 <code>dict.h/dictEntry</code> 结构的指针， 每个 <code>dictEntry</code> 结构保存着一个键值对。</p>
<p><code>size</code> 属性记录了哈希表的大小， 也即是 <code>table</code> 数组的大小， 而 <code>used</code> 属性则记录了哈希表目前已有节点（键值对）的数量。</p>
<p><code>sizemask</code> 属性的值总是等于 <code>size - 1</code> ， 这个属性和哈希值一起决定一个键应该被放到 <code>table</code> 数组的哪个索引上面。</p>
<p>图 4-1 展示了一个大小为 <code>4</code> 的空哈希表 （没有包含任何键值对）。</p>
<p>![5](redis 数据结构对象.assets&#x2F;5.png)</p>
<h2 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h2><p>哈希表节点使用 <code>dictEntry</code> 结构表示， 每个 <code>dictEntry</code> 结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>





<p><code>key</code> 属性保存着键值对中的键， 而 <code>v</code> 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 <code>uint64_t</code> 整数， 又或者是一个 <code>int64_t</code> 整数。</p>
<p><code>next</code> 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</p>
<p>举个例子， 图 4-2 就展示了如何通过 <code>next</code> 指针， 将两个索引值相同的键 <code>k1</code> 和 <code>k0</code> 连接在一起。</p>
<p>![6](redis 数据结构对象.assets&#x2F;6.png)</p>
<h2 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h2><p>Redis 中的字典由 <code>dict.h/dict</code> 结构表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>





<p><code>type</code> 属性和 <code>privdata</code> 属性是针对不同类型的键值对， 为创建多态字典而设置的：</p>
<ul>
<li><code>type</code> 属性是一个指向 <code>dictType</code> 结构的指针， 每个 <code>dictType</code> 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li>
<li>而 <code>privdata</code> 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line"></span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>





<p><code>ht</code> 属性是一个包含两个项的数组， 数组中的每个项都是一个 <code>dictht</code> 哈希表， 一般情况下， 字典只使用 <code>ht[0]</code> 哈希表， <code>ht[1]</code> 哈希表只会在对 <code>ht[0]</code> 哈希表进行 rehash 时使用。</p>
<p>除了 <code>ht[1]</code> 之外， 另一个和 rehash 有关的属性就是 <code>rehashidx</code> ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 <code>-1</code> 。</p>
<p>图 4-3 展示了一个普通状态下（没有进行 rehash）的字典：</p>
<p>![7](redis 数据结构对象.assets&#x2F;7.png)</p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<p>Redis 计算哈希值和索引值的方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用字典设置的哈希函数，计算键 key 的哈希值</span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"></span><br><span class="line"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span><br><span class="line"># 根据情况不同， ht[x] 可以是 ht[0] 或者 ht[1]</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<p>![8](redis 数据结构对象.assets&#x2F;8.png)</p>
<p>举个例子， 对于图 4-4 所示的字典来说， 如果我们要将一个键值对 <code>k0</code> 和 <code>v0</code> 添加到字典里面， 那么程序会先使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = dict-&gt;type-&gt;hashFunction(k0);</span><br></pre></td></tr></table></figure>

<p>计算键 <code>k0</code> 的哈希值。</p>
<p>假设计算得出的哈希值为 <code>8</code> ， 那么程序会继续使用语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = hash &amp; dict-&gt;ht[0].sizemask = 8 &amp; 3 = 0;</span><br></pre></td></tr></table></figure>

<p>计算出键 <code>k0</code> 的索引值 <code>0</code> ， 这表示包含键值对 <code>k0</code> 和 <code>v0</code> 的节点应该被放置到哈希表数组的索引 <code>0</code> 位置上， 如图 4-5 所示。</p>
<p>![9](redis 数据结构对象.assets&#x2F;9.png)</p>
<p>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</p>
<p>MurmurHash 算法最初由 Austin Appleby 于 2008 年发明， 这种算法的优点在于， 即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。</p>
<p>MurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： <a target="_blank" rel="noopener" href="http://code.google.com/p/smhasher/">http://code.google.com/p/smhasher/</a> 。</p>
<h2 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h2><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。</p>
<p>Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 <code>next</code> 指针， 多个哈希表节点可以用 <code>next</code> 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。</p>
<p>举个例子， 假设程序要将键值对 <code>k2</code> 和 <code>v2</code> 添加到图 4-6 所示的哈希表里面， 并且计算得出 <code>k2</code> 的索引值为 <code>2</code> ， 那么键 <code>k1</code> 和 <code>k2</code> 将产生冲突， 而解决冲突的办法就是使用 <code>next</code> 指针将键 <code>k2</code> 和 <code>k1</code> 所在的节点连接起来， 如图 4-7 所示。</p>
<p>![10](redis 数据结构对象.assets&#x2F;10.png)</p>
<p>![11](redis 数据结构对象.assets&#x2F;11.png)</p>
<p>因为 <code>dictEntry</code> 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O(1)）， 排在其他已有节点的前面。</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<p>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li>为字典的ht[1]哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及ht[0]当前包含的键值对数量 （也即是ht[0].used属性的值）：<ul>
<li>如果执行的是扩展操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used * 2</code> 的 2^n （<code>2</code> 的 <code>n</code> 次方幂）；</li>
<li>如果执行的是收缩操作， 那么 <code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used</code> 的 2^n 。</li>
</ul>
</li>
<li>将保存在 <code>ht[0]</code> 中的所有键值对 rehash 到 <code>ht[1]</code> 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 <code>ht[1]</code> 哈希表的指定位置上。</li>
<li>当 <code>ht[0]</code> 包含的所有键值对都迁移到了 <code>ht[1]</code> 之后 （<code>ht[0]</code> 变为空表）， 释放 <code>ht[0]</code> ， 将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ， 并在 <code>ht[1]</code> 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<p>举个例子， 假设程序要对图 4-8 所示字典的 <code>ht[0]</code> 进行扩展操作， 那么程序将执行以下步骤：</p>
<ol>
<li><code>ht[0].used</code> 当前的值为 <code>4</code> ， <code>4 * 2 = 8</code> ， 而 <code>8</code> （2^3）恰好是第一个大于等于 <code>4</code> 的 <code>2</code> 的 <code>n</code> 次方， 所以程序会将 <code>ht[1]</code> 哈希表的大小设置为 <code>8</code> 。 图 4-9 展示了 <code>ht[1]</code> 在分配空间之后， 字典的样子。</li>
<li>将 <code>ht[0]</code> 包含的四个键值对都 rehash 到 <code>ht[1]</code> ， 如图 4-10 所示。</li>
<li>释放 <code>ht[0]</code> ，并将 <code>ht[1]</code> 设置为 <code>ht[0]</code> ，然后为 <code>ht[1]</code> 分配一个空白哈希表，如图 4-11 所示。</li>
</ol>
<p>至此， 对哈希表的扩展操作执行完毕， 程序成功将哈希表的大小从原来的 <code>4</code> 改为了现在的 <code>8</code> 。</p>
<p>![12](redis 数据结构对象.assets&#x2F;12.png)</p>
<p>![13](redis 数据结构对象.assets&#x2F;13.png)</p>
<p>![14](redis 数据结构对象.assets&#x2F;14.png)</p>
<h2 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h2><p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>
<ol>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>1</code> ；</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 <code>5</code> ；</li>
</ol>
<p>其中哈希表的负载因子可以通过公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 负载因子 = 哈希表已保存节点数量 / 哈希表大小</span><br><span class="line">load_factor = ht[0].used / ht[0].size</span><br></pre></td></tr></table></figure>

<p>计算得出。</p>
<p>比如说， 对于一个大小为 <code>4</code> ， 包含 <code>4</code> 个键值对的哈希表来说， 这个哈希表的负载因子为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor = 4 / 4 = 1</span><br></pre></td></tr></table></figure>

<p>又比如说， 对于一个大小为 <code>512</code> ， 包含 <code>256</code> 个键值对的哈希表来说， 这个哈希表的负载因子为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_factor = 256 / 512 = 0.5</span><br></pre></td></tr></table></figure>

<p>根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 BGSAVE 命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制（<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a>）技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存。</p>
<p>另一方面， 当哈希表的负载因子小于 <code>0.1</code> 时， 程序自动开始对哈希表执行收缩操作。</p>
<h2 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h2><p>上一节说过， 扩展或收缩哈希表需要将 <code>ht[0]</code> 里面的所有键值对 rehash 到 <code>ht[1]</code> 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。</p>
<p>这样做的原因在于， 如果 <code>ht[0]</code> 里只保存着四个键值对， 那么服务器可以在瞬间就将这些键值对全部 rehash 到 <code>ht[1]</code> ； 但是， 如果哈希表里保存的键值对数量不是四个， 而是四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 <code>ht[1]</code> 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 <code>ht[0]</code> 里面的所有键值对全部 rehash 到 <code>ht[1]</code> ， 而是分多次、渐进式地将 <code>ht[0]</code> 里面的键值对慢慢地 rehash 到 <code>ht[1]</code> 。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间， 让字典同时持有 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 <code>rehashidx</code> ， 并将它的值设置为 <code>0</code> ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 <code>ht[0]</code> 哈希表在 <code>rehashidx</code> 索引上的所有键值对 rehash 到 <code>ht[1]</code> ， 当 rehash 工作完成之后， 程序将 <code>rehashidx</code> 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， <code>ht[0]</code> 的所有键值对都会被 rehash 至 <code>ht[1]</code> ， 这时程序将 <code>rehashidx</code> 属性的值设为 <code>-1</code> ， 表示 rehash 操作已完成。</li>
</ol>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<p>图 4-12 至图 4-17 展示了一次完整的渐进式 rehash 过程， 注意观察在整个 rehash 过程中， 字典的 <code>rehashidx</code> 属性是如何变化的。</p>
<p>![16](redis 数据结构对象.assets&#x2F;16.png)</p>
<p>![17](redis 数据结构对象.assets&#x2F;17.png)</p>
<p>![18](redis 数据结构对象.assets&#x2F;18.png)</p>
<p>![19](redis 数据结构对象.assets&#x2F;19.png)</p>
<p>![20](redis 数据结构对象.assets&#x2F;20.png)</p>
<p>![21](redis 数据结构对象.assets&#x2F;21.png)</p>
<h2 id="渐进式-rehash-执行期间的哈希表操作"><a href="#渐进式-rehash-执行期间的哈希表操作" class="headerlink" title="渐进式 rehash 执行期间的哈希表操作"></a>渐进式 rehash 执行期间的哈希表操作</h2><p>因为在进行渐进式 rehash 的过程中， 字典会同时使用 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表， 所以在渐进式 rehash 进行期间， 字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行： 比如说， 要在字典里面查找一个键的话， 程序会先在 <code>ht[0]</code> 里面进行查找， 如果没找到的话， 就会继续到 <code>ht[1]</code> 里面进行查找， 诸如此类。</p>
<p>另外， 在渐进式 rehash 执行期间， 新添加到字典的键值对一律会被保存到 <code>ht[1]</code> 里面， 而 <code>ht[0]</code> 则不再进行任何添加操作： 这一措施保证了 <code>ht[0]</code> 包含的键值对数量会只减不增， 并随着 rehash 操作的执行而最终变成空表。</p>
<h2 id="字典-API"><a href="#字典-API" class="headerlink" title="字典 API"></a>字典 API</h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>dictCreate</code></td>
<td>创建一个新的字典。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>dictAdd</code></td>
<td>将给定的键值对添加到字典里面。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>dictReplace</code></td>
<td>将给定的键值对添加到字典里面， 如果键已经存在于字典，那么用新值取代原有的值。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>dictFetchValue</code></td>
<td>返回给定键的值。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>dictGetRandomKey</code></td>
<td>从字典中随机返回一个键值对。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>dictDelete</code></td>
<td>从字典中删除给定键所对应的键值对。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>dictRelease</code></td>
<td>释放给定字典，以及字典中包含的所有键值对。</td>
<td>O(N) ， <code>N</code> 为字典包含的键值对数量。</td>
</tr>
</tbody></table>
<h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><p>跳跃表（skiplist）是一种有序数据结构， 它通过在每个节点中维持多个指向其他节点的指针， 从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均 O(\log N) 最坏 O(N) 复杂度的节点查找， 还可以通过顺序性操作来批量处理节点。</p>
<p>在大部分情况下， 跳跃表的效率可以和平衡树相媲美， 并且因为跳跃表的实现比平衡树要来得更为简单， 所以有不少程序都使用跳跃表来代替平衡树。</p>
<p>Redis 使用跳跃表作为有序集合键的底层实现之一： 如果一个有序集合包含的元素数量比较多， 又或者有序集合中元素的成员（member）是比较长的字符串时， Redis 就会使用跳跃表来作为有序集合键的底层实现。</p>
<p>举个例子， <code>fruit-price</code> 是一个有序集合键， 这个有序集合以水果名为成员， 水果价钱为分值， 保存了 <code>130</code> 款水果的价钱：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">ZRANGE fruit-price 0 2 WITHSCORES</span></span><br><span class="line">1) &quot;banana&quot;</span><br><span class="line">2) &quot;5&quot;</span><br><span class="line">3) &quot;cherry&quot;</span><br><span class="line">4) &quot;6.5&quot;</span><br><span class="line">5) &quot;apple&quot;</span><br><span class="line">6) &quot;8&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">ZCARD fruit-price</span></span><br><span class="line">(integer) 130</span><br></pre></td></tr></table></figure>

<p><code>fruit-price</code> 有序集合的所有数据都保存在一个跳跃表里面， 其中每个跳跃表节点（node）都保存了一款水果的价钱信息， 所有水果按价钱的高低从低到高在跳跃表里面排序：</p>
<ul>
<li>跳跃表的第一个元素的成员为 <code>&quot;banana&quot;</code> ， 它的分值为 <code>5</code> ；</li>
<li>跳跃表的第二个元素的成员为 <code>&quot;cherry&quot;</code> ， 它的分值为 <code>6.5</code> ；</li>
<li>跳跃表的第三个元素的成员为 <code>&quot;apple&quot;</code> ， 它的分值为 <code>8</code> ；</li>
</ul>
<p>诸如此类。</p>
<p>和链表、字典等数据结构被广泛地应用在 Redis 内部不同， Redis 只在两个地方用到了跳跃表， 一个是实现有序集合键， 另一个是在集群节点中用作内部数据结构， 除此之外， 跳跃表在 Redis 里面没有其他用途。</p>
<h2 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h2><p>Redis 的跳跃表由 <code>redis.h/zskiplistNode</code> 和 <code>redis.h/zskiplist</code> 两个结构定义， 其中 <code>zskiplistNode</code> 结构用于表示跳跃表节点， 而 <code>zskiplist</code> 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。</p>
<p>![22](redis 数据结构对象.assets&#x2F;22.png)</p>
<p>图 5-1 展示了一个跳跃表示例， 位于图片最左边的是 <code>zskiplist</code> 结构， 该结构包含以下属性：</p>
<ul>
<li><code>header</code> ：指向跳跃表的表头节点。</li>
<li><code>tail</code> ：指向跳跃表的表尾节点。</li>
<li><code>level</code> ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li>
<li><code>length</code> ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li>
</ul>
<p>位于 <code>zskiplist</code> 结构右方的是四个 <code>zskiplistNode</code> 结构， 该结构包含以下属性：</p>
<ul>
<li>层（level）：节点中用 <code>L1</code> 、 <code>L2</code> 、 <code>L3</code> 等字样标记节点的各个层， <code>L1</code> 代表第一层， <code>L2</code> 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li>
<li>后退（backward）指针：节点中用 <code>BW</code> 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值（score）：各个节点中的 <code>1.0</code> 、 <code>2.0</code> 和 <code>3.0</code> 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li>成员对象（obj）：各个节点中的 <code>o1</code> 、 <code>o2</code> 和 <code>o3</code> 是节点所保存的成员对象。</li>
</ul>
<p>注意表头节点和其他节点的构造是一样的： 表头节点也有后退指针、分值和成员对象， 不过表头节点的这些属性都不会被用到， 所以图中省略了这些部分， 只显示了表头节点的各个层。</p>
<h2 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h2><p>跳跃表节点的实现由 <code>redis.h/zskiplistNode</code> 结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>





<h3 id="1-层"><a href="#1-层" class="headerlink" title="1. 层"></a>1. 层</h3><p>跳跃表节点的 <code>level</code> 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p>
<p>每次创建一个新跳跃表节点的时候， 程序都根据幂次定律 （<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Power_law">power law</a>，越大的数出现的概率越小） 随机生成一个介于 <code>1</code> 和 <code>32</code> 之间的值作为 <code>level</code> 数组的大小， 这个大小就是层的“高度”。</p>
<p>图 5-2 分别展示了三个高度为 <code>1</code> 层、 <code>3</code> 层和 <code>5</code> 层的节点， 因为 C 语言的数组索引总是从 <code>0</code> 开始的， 所以节点的第一层是 <code>level[0]</code> ， 而第二层是 <code>level[1]</code> ， 以此类推。</p>
<p>![23](redis 数据结构对象.assets&#x2F;23.png)</p>
<h3 id="2-前进指针"><a href="#2-前进指针" class="headerlink" title="2. 前进指针"></a>2. 前进指针</h3><p>每个层都有一个指向表尾方向的前进指针（<code>level[i].forward</code> 属性）， 用于从表头向表尾方向访问节点。</p>
<p>图 5-3 用虚线表示出了程序从表头向表尾方向， 遍历跳跃表中所有节点的路径：</p>
<ol>
<li>迭代程序首先访问跳跃表的第一个节点（表头）， 然后从第四层的前进指针移动到表中的第二个节点。</li>
<li>在第二个节点时， 程序沿着第二层的前进指针移动到表中的第三个节点。</li>
<li>在第三个节点时， 程序同样沿着第二层的前进指针移动到表中的第四个节点。</li>
<li>当程序再次沿着第四个节点的前进指针移动时， 它碰到一个 <code>NULL</code> ， 程序知道这时已经到达了跳跃表的表尾， 于是结束这次遍历。</li>
</ol>
<p>![24](redis 数据结构对象.assets&#x2F;24.png)</p>
<h3 id="3-跨度"><a href="#3-跨度" class="headerlink" title="3. 跨度"></a>3. 跨度</h3><p>层的跨度（<code>level[i].span</code> 属性）用于记录两个节点之间的距离：</p>
<ul>
<li>两个节点之间的跨度越大， 它们相距得就越远。</li>
<li>指向 <code>NULL</code> 的所有前进指针的跨度都为 <code>0</code> ， 因为它们没有连向任何节点。</li>
</ul>
<p>初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 —— 遍历操作只使用前进指针就可以完成了， 跨度实际上是用来计算排位（rank）的： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</p>
<p>举个例子， 图 5-4 用虚线标记了在跳跃表中查找分值为 <code>3.0</code> 、 成员对象为 <code>o3</code> 的节点时， 沿途经历的层： 查找的过程只经过了一个层， 并且层的跨度为 <code>3</code> ， 所以目标节点在跳跃表中的排位为 <code>3</code> 。</p>
<p>![25](redis 数据结构对象.assets&#x2F;25.png)</p>
<p>再举个例子， 图 5-5 用虚线标记了在跳跃表中查找分值为 <code>2.0</code> 、 成员对象为 <code>o2</code> 的节点时， 沿途经历的层： 在查找节点的过程中， 程序经过了两个跨度为 <code>1</code> 的节点， 因此可以计算出， 目标节点在跳跃表中的排位为 2 。</p>
<p>![26](redis 数据结构对象.assets&#x2F;26.png)</p>
<h3 id="4-后退指针"><a href="#4-后退指针" class="headerlink" title="4. 后退指针"></a>4. 后退指针</h3><p>节点的后退指针（<code>backward</code> 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</p>
<p>图 5-6 用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点： 程序首先通过跳跃表的 <code>tail</code> 指针访问表尾节点， 然后通过后退指针访问倒数第二个节点， 之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 <code>NULL</code> 的后退指针， 于是访问结束。</p>
<p>![27](redis 数据结构对象.assets&#x2F;27.png)</p>
<h3 id="5-分值和成员"><a href="#5-分值和成员" class="headerlink" title="5. 分值和成员"></a>5. 分值和成员</h3><p>节点的分值（<code>score</code> 属性）是一个 <code>double</code> 类型的浮点数， 跳跃表中的所有节点都按分值从小到大来排序。</p>
<p>节点的成员对象（<code>obj</code> 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</p>
<p>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。</p>
<p>举个例子， 在图 5-7 所示的跳跃表中， 三个跳跃表节点都保存了相同的分值 <code>10086.0</code> ， 但保存成员对象 <code>o1</code> 的节点却排在保存成员对象 <code>o2</code> 和 <code>o3</code> 的节点之前， 而保存成员对象 <code>o2</code> 的节点又排在保存成员对象 <code>o3</code> 的节点之前， 由此可见， <code>o1</code> 、 <code>o2</code> 、 <code>o3</code> 三个成员对象在字典中的排序为 <code>o1 &lt;= o2 &lt;= o3</code> 。</p>
<p>![28.png](redis 数据结构对象.assets&#x2F;28.png.png)</p>
<h2 id="跳跃表-1"><a href="#跳跃表-1" class="headerlink" title="跳跃表"></a>跳跃表</h2><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表， 如图 5-8 所示。</p>
<p>![29](redis 数据结构对象.assets&#x2F;29.png)</p>
<p>但通过使用一个 <code>zskiplist</code> 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息， 如图 5-9 所示。</p>
<p>![30](redis 数据结构对象.assets&#x2F;30.png)</p>
<p><code>zskiplist</code> 结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p><code>header</code> 和 <code>tail</code> 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。</p>
<p>通过使用 <code>length</code> 属性来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。</p>
<p><code>level</code> 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在内。</p>
<h2 id="跳跃表API"><a href="#跳跃表API" class="headerlink" title="跳跃表API"></a>跳跃表API</h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>zslCreate</code></td>
<td>创建一个新的跳跃表。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>zslFree</code></td>
<td>释放给定跳跃表，以及表中包含的所有节点。</td>
<td>O(N) ， <code>N</code> 为跳跃表的长度。</td>
</tr>
<tr>
<td><code>zslInsert</code></td>
<td>将包含给定成员和分值的新节点添加到跳跃表中。</td>
<td>平均 O(\log N) ，最坏 O(N) ， <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td><code>zslDelete</code></td>
<td>删除跳跃表中包含给定成员和分值的节点。</td>
<td>平均 O(\log N) ，最坏 O(N) ， <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td><code>zslGetRank</code></td>
<td>返回包含给定成员和分值的节点在跳跃表中的排位。</td>
<td>平均 O(\log N) ，最坏 O(N) ， <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td><code>zslGetElementByRank</code></td>
<td>返回跳跃表在给定排位上的节点。</td>
<td>平均 O(\log N) ，最坏 O(N) ， <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td><code>zslIsInRange</code></td>
<td>给定一个分值范围（range）， 比如 <code>0</code> 到 <code>15</code> ， <code>20</code> 到 <code>28</code> ，诸如此类， 如果给定的分值范围包含在跳跃表的分值范围之内， 那么返回 <code>1</code> ，否则返回 <code>0</code> 。</td>
<td>通过跳跃表的表头节点和表尾节点， 这个检测可以用 O(1) 复杂度完成。</td>
</tr>
<tr>
<td><code>zslFirstInRange</code></td>
<td>给定一个分值范围， 返回跳跃表中第一个符合这个范围的节点。</td>
<td>平均 O(\log N) ，最坏 O(N) 。 <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td><code>zslLastInRange</code></td>
<td>给定一个分值范围， 返回跳跃表中最后一个符合这个范围的节点。</td>
<td>平均 O(\log N) ，最坏 O(N) 。 <code>N</code> 为跳跃表长度。</td>
</tr>
<tr>
<td><code>zslDeleteRangeByScore</code></td>
<td>给定一个分值范围， 删除跳跃表中所有在这个范围之内的节点。</td>
<td>O(N) ， <code>N</code> 为被删除节点数量。</td>
</tr>
<tr>
<td><code>zslDeleteRangeByRank</code></td>
<td>给定一个排位范围， 删除跳跃表中所有在这个范围之内的节点。</td>
<td>O(N) ， <code>N</code> 为被删除节点数量。</td>
</tr>
</tbody></table>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>跳跃表是有序集合的底层实现之一， 除此之外它在 Redis 中没有其他应用。</li>
<li>Redis 的跳跃表实现由 <code>zskiplist</code> 和 <code>zskiplistNode</code> 两个结构组成， 其中 <code>zskiplist</code> 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而 <code>zskiplistNode</code> 则用于表示跳跃表节点。</li>
<li>每个跳跃表节点的层高都是 <code>1</code> 至 <code>32</code> 之间的随机数。</li>
<li>在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是唯一的。</li>
<li>跳跃表中的节点按照分值大小进行排序， 当分值相同时， 节点按照成员对象的大小进行排序。</li>
</ul>
<h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>整数集合（intset）是集合键的底层实现之一： 当一个集合只包含整数值元素， 并且这个集合的元素数量不多时， Redis 就会使用整数集合作为集合键的底层实现。</p>
<p>举个例子， 如果我们创建一个只包含五个元素的集合键， 并且集合中的所有元素都是整数值， 那么这个集合键的底层实现就会是整数集合：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SADD numbers 1 3 5 7 9</span></span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING numbers</span></span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure>







<h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 的整数值， 并且保证集合中不会出现重复元素。</p>
<p>每个 <code>intset.h/intset</code> 结构表示一个整数集合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct intset &#123;</span><br><span class="line"></span><br><span class="line">    // 编码方式</span><br><span class="line">    uint32_t encoding;</span><br><span class="line"></span><br><span class="line">    // 集合包含的元素数量</span><br><span class="line">    uint32_t length;</span><br><span class="line"></span><br><span class="line">    // 保存元素的数组</span><br><span class="line">    int8_t contents[];</span><br><span class="line"></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p><code>contents</code> 数组是整数集合的底层实现： 整数集合的每个元素都是 <code>contents</code> 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
<p><code>length</code> 属性记录了整数集合包含的元素数量， 也即是 <code>contents</code> 数组的长度。</p>
<p>虽然 <code>intset</code> 结构将 <code>contents</code> 属性声明为 <code>int8_t</code> 类型的数组， 但实际上 <code>contents</code> 数组并不保存任何 <code>int8_t</code> 类型的值 —— <code>contents</code> 数组的真正类型取决于 <code>encoding</code> 属性的值：</p>
<ul>
<li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT16</code> ， 那么 <code>contents</code> 就是一个 <code>int16_t</code> 类型的数组， 数组里的每个项都是一个 <code>int16_t</code> 类型的整数值 （最小值为 <code>-32,768</code> ，最大值为 <code>32,767</code> ）。</li>
<li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT32</code> ， 那么 <code>contents</code> 就是一个 <code>int32_t</code> 类型的数组， 数组里的每个项都是一个 <code>int32_t</code> 类型的整数值 （最小值为 <code>-2,147,483,648</code> ，最大值为 <code>2,147,483,647</code> ）。</li>
<li>如果 <code>encoding</code> 属性的值为 <code>INTSET_ENC_INT64</code> ， 那么 <code>contents</code> 就是一个 <code>int64_t</code> 类型的数组， 数组里的每个项都是一个 <code>int64_t</code> 类型的整数值 （最小值为 <code>-9,223,372,036,854,775,808</code> ，最大值为 <code>9,223,372,036,854,775,807</code> ）。</li>
</ul>
<p>图 6-1 展示了一个整数集合示例：</p>
<ul>
<li><code>encoding</code> 属性的值为 <code>INTSET_ENC_INT16</code> ， 表示整数集合的底层实现为 <code>int16_t</code> 类型的数组， 而集合保存的都是 <code>int16_t</code> 类型的整数值。</li>
<li><code>length</code> 属性的值为 <code>5</code> ， 表示整数集合包含五个元素。</li>
<li><code>contents</code> 数组按从小到大的顺序保存着集合中的五个元素。</li>
<li>因为每个集合元素都是 <code>int16_t</code> 类型的整数值， 所以 <code>contents</code> 数组的大小等于 <code>sizeof(int16_t) * 5 = 16 * 5 = 80</code> 位。</li>
</ul>
<p>![31](redis 数据结构对象.assets&#x2F;31.png)</p>
<p>图 6-2 展示了另一个整数集合示例：</p>
<ul>
<li><code>encoding</code> 属性的值为 <code>INTSET_ENC_INT64</code> ， 表示整数集合的底层实现为 <code>int64_t</code> 类型的数组， 而数组中保存的都是 <code>int64_t</code> 类型的整数值。</li>
<li><code>length</code> 属性的值为 <code>4</code> ， 表示整数集合包含四个元素。</li>
<li><code>contents</code> 数组按从小到大的顺序保存着集合中的四个元素。</li>
<li>因为每个集合元素都是 <code>int64_t</code> 类型的整数值， 所以 <code>contents</code> 数组的大小为 <code>sizeof(int64_t) * 4 = 64 * 4 = 256</code> 位。</li>
</ul>
<p>![32](redis 数据结构对象.assets&#x2F;32.png)</p>
<p>虽然 <code>contents</code> 数组保存的四个整数值中， 只有 <code>-2675256175807981027</code> 是真正需要用 <code>int64_t</code> 类型来保存的， 而其他的 <code>1</code> 、 <code>3</code> 、 <code>5</code> 三个值都可以用 <code>int16_t</code> 类型来保存， 不过根据整数集合的升级规则， 当向一个底层为 <code>int16_t</code> 数组的整数集合添加一个 <code>int64_t</code> 类型的整数值时， 整数集合已有的所有元素都会被转换成 <code>int64_t</code> 类型， 所以 <code>contents</code> 数组保存的四个整数值都是 <code>int64_t</code> 类型的， 不仅仅是 <code>-2675256175807981027</code> 。</p>
<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<ol>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<p>举个例子， 假设现在有一个 <code>INTSET_ENC_INT16</code> 编码的整数集合， 集合中包含三个 <code>int16_t</code> 类型的元素， 如图 6-3 所示。</p>
<p>![33](redis 数据结构对象.assets&#x2F;33.png)</p>
<p>因为每个元素都占用 <code>16</code> 位空间， 所以整数集合底层数组的大小为 <code>3 * 16 = 48</code> 位， 图 6-4 展示了整数集合的三个元素在这 <code>48</code> 位里的位置。</p>
<p>![34](redis 数据结构对象.assets&#x2F;34.png)</p>
<p>现在， 假设我们要将类型为 <code>int32_t</code> 的整数值 <code>65535</code> 添加到整数集合里面， 因为 <code>65535</code> 的类型 <code>int32_t</code> 比整数集合当前所有元素的类型都要长， 所以在将 <code>65535</code> 添加到整数集合之前， 程序需要先对整数集合进行升级。</p>
<p>升级首先要做的是， 根据新类型的长度， 以及集合元素的数量（包括要添加的新元素在内）， 对底层数组进行空间重分配。</p>
<p>整数集合目前有三个元素， 再加上新元素 <code>65535</code> ， 整数集合需要分配四个元素的空间， 因为每个 <code>int32_t</code> 整数值需要占用 <code>32</code> 位空间， 所以在空间重分配之后， 底层数组的大小将是 <code>32 * 4 = 128</code> 位， 如图 6-5 所示。</p>
<p>![35](redis 数据结构对象.assets&#x2F;35.png)</p>
<p>虽然程序对底层数组进行了空间重分配， 但数组原有的三个元素 <code>1</code> 、 <code>2</code> 、 <code>3</code> 仍然是 <code>int16_t</code> 类型， 这些元素还保存在数组的前 <code>48</code> 位里面， 所以程序接下来要做的就是将这三个元素转换成 <code>int32_t</code> 类型， 并将转换后的元素放置到正确的位上面， 而且在放置元素的过程中， 需要维持底层数组的有序性质不变。</p>
<p>首先， 因为元素 <code>3</code> 在 <code>1</code> 、 <code>2</code> 、 <code>3</code> 、 <code>65535</code> 四个元素中排名第三， 所以它将被移动到 <code>contents</code> 数组的索引 <code>2</code> 位置上， 也即是数组 <code>64</code> 位至 <code>95</code> 位的空间内， 如图 6-6 所示。</p>
<p>![36](redis 数据结构对象.assets&#x2F;36.png)</p>
<p>接着， 因为元素 <code>2</code> 在 <code>1</code> 、 <code>2</code> 、 <code>3</code> 、 <code>65535</code> 四个元素中排名第二， 所以它将被移动到 <code>contents</code> 数组的索引 <code>1</code> 位置上， 也即是数组的 <code>32</code> 位至 <code>63</code> 位的空间内， 如图 6-7 所示。</p>
<p>![37](redis 数据结构对象.assets&#x2F;37.png)</p>
<p>之后， 因为元素 <code>1</code> 在 <code>1</code> 、 <code>2</code> 、 <code>3</code> 、 <code>65535</code> 四个元素中排名第一， 所以它将被移动到 <code>contents</code> 数组的索引 <code>0</code> 位置上， 也即是数组的 <code>0</code> 位至 <code>31</code> 位的空间内， 如图 6-8 所示。</p>
<p>![38](redis 数据结构对象.assets&#x2F;38.png)</p>
<p>然后， 因为元素 <code>65535</code> 在 <code>1</code> 、 <code>2</code> 、 <code>3</code> 、 <code>65535</code> 四个元素中排名第四， 所以它将被添加到 <code>contents</code> 数组的索引 <code>3</code> 位置上， 也即是数组的 <code>96</code> 位至 <code>127</code> 位的空间内， 如图 6-9 所示。</p>
<p>![39](redis 数据结构对象.assets&#x2F;39.png)</p>
<p>最后， 程序将整数集合 <code>encoding</code> 属性的值从 <code>INTSET_ENC_INT16</code> 改为 <code>INTSET_ENC_INT32</code> ， 并将 <code>length</code> 属性的值从 <code>3</code> 改为 <code>4</code> ， 设置完成之后的整数集合如图 6-10 所示。</p>
<p>![40](redis 数据结构对象.assets&#x2F;40.png)</p>
<p>因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。</p>
<p>其他类型的升级操作， 比如从 <code>INTSET_ENC_INT16</code> 编码升级为 <code>INTSET_ENC_INT64</code> 编码， 或者从 <code>INTSET_ENC_INT32</code> 编码升级为 <code>INTSET_ENC_INT64</code> 编码， 升级的过程都和上面展示的升级过程类似。</p>
<p>升级之后新元素的摆放位置</p>
<p>因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：</p>
<ul>
<li>在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 <code>0</code> ）；</li>
<li>在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 <code>length-1</code> ）。</li>
</ul>
<h2 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h2><p>整数集合的升级策略有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。</p>
<h3 id="提升灵活性"><a href="#提升灵活性" class="headerlink" title="提升灵活性"></a>提升灵活性</h3><p>因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。</p>
<p>比如说， 我们一般只使用 <code>int16_t</code> 类型的数组来保存 <code>int16_t</code> 类型的值， 只使用 <code>int32_t</code> 类型的数组来保存 <code>int32_t</code> 类型的值， 诸如此类。</p>
<p>但是， 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 <code>int16_t</code> 、 <code>int32_t</code> 或者 <code>int64_t</code> 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</p>
<h3 id="节约内存"><a href="#节约内存" class="headerlink" title="节约内存"></a>节约内存</h3><p>当然， 要让一个数组可以同时保存 <code>int16_t</code> 、 <code>int32_t</code> 、 <code>int64_t</code> 三种类型的值， 最简单的做法就是直接使用 <code>int64_t</code> 类型的数组作为整数集合的底层实现。 不过这样一来， 即使添加到整数集合里面的都是 <code>int16_t</code> 类型或者 <code>int32_t</code> 类型的值， 数组都需要使用 <code>int64_t</code> 类型的空间去保存它们， 从而出现浪费内存的情况。</p>
<p>而整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
<p>比如说， 如果我们一直只向整数集合添加 <code>int16_t</code> 类型的值， 那么整数集合的底层实现就会一直是 <code>int16_t</code> 类型的数组， 只有在我们要将 <code>int32_t</code> 类型或者 <code>int64_t</code> 类型的值添加到集合时， 程序才会对数组进行升级。</p>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<p>举个例子， 对于图 6-11 所示的整数集合来说， 即使我们将集合里唯一一个真正需要使用 <code>int64_t</code> 类型来保存的元素 <code>4294967295</code> 删除了， 整数集合的编码仍然会维持 <code>INTSET_ENC_INT64</code> ， 底层数组也仍然会是 <code>int64_t</code> 类型的， 如图 6-12 所示。</p>
<p>![41](redis 数据结构对象.assets&#x2F;41.png)</p>
<p>![42](redis 数据结构对象.assets&#x2F;42.png)</p>
<h2 id="整数集合-API"><a href="#整数集合-API" class="headerlink" title="整数集合 API"></a>整数集合 API</h2><table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>intsetNew</code></td>
<td>创建一个新的整数集合。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>intsetAdd</code></td>
<td>将给定元素添加到整数集合里面。</td>
<td>O(N)</td>
</tr>
<tr>
<td><code>intsetRemove</code></td>
<td>从整数集合中移除给定元素。</td>
<td>O(N)</td>
</tr>
<tr>
<td><code>intsetFind</code></td>
<td>检查给定值是否存在于集合。</td>
<td>因为底层数组有序，查找可以通过二分查找法来进行， 所以复杂度为 O(\log N) 。</td>
</tr>
<tr>
<td><code>intsetRandom</code></td>
<td>从整数集合中随机返回一个元素。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>intsetGet</code></td>
<td>取出底层数组在给定索引上的元素。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>intsetLen</code></td>
<td>返回整数集合包含的元素个数。</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>intsetBlobLen</code></td>
<td>返回整数集合占用的内存字节数。</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li>整数集合是集合键的底层实现之一。</li>
<li>整数集合的底层实现为数组， 这个数组以有序、无重复的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。</li>
<li>升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。</li>
<li>整数集合只支持升级操作， 不支持降级操作。</li>
</ul>
<h1 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h1><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一。</p>
<p>当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。</p>
<p>比如说， 执行以下命令将创建一个压缩列表实现的列表键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH lst 1 3 5 10086 &quot;hello&quot; &quot;world&quot;</span><br><span class="line">(integer) 6</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING lst</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure>

<p>因为列表键里面包含的都是 <code>1</code> 、 <code>3</code> 、 <code>5</code> 、 <code>10086</code> 这样的小整数值， 以及 <code>&quot;hello&quot;</code> 、 <code>&quot;world&quot;</code> 这样的短字符串。</p>
<p>另外， 当一个哈希键只包含少量键值对， 并且每个键值对的键和值要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做哈希键的底层实现。</p>
<p>举个例子， 执行以下命令将创建一个压缩列表实现的哈希键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HMSET profile &quot;name&quot; &quot;Jack&quot; &quot;age&quot; 28 &quot;job&quot; &quot;Programmer&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING profile</span><br><span class="line">&quot;ziplist&quot;</span><br></pre></td></tr></table></figure>

<p>因为哈希键里面包含的所有键和值都是小整数值或者短字符串。</p>
<h2 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h2><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。</p>
<p>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。</p>
<p>图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。</p>
<p>![43](redis 数据结构对象.assets&#x2F;43.png)</p>
<p>表 7-1 压缩列表各个组成部分的详细说明</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">长度</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>zlbytes</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left"><code>4</code> 字节</td>
<td align="left">记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配， 或者计算 <code>zlend</code> 的位置时使用。</td>
</tr>
<tr>
<td align="left"><code>zltail</code></td>
<td align="left"><code>uint32_t</code></td>
<td align="left"><code>4</code> 字节</td>
<td align="left">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</td>
</tr>
<tr>
<td align="left"><code>zllen</code></td>
<td align="left"><code>uint16_t</code></td>
<td align="left"><code>2</code> 字节</td>
<td align="left">记录了压缩列表包含的节点数量： 当这个属性的值小于 <code>UINT16_MAX</code> （<code>65535</code>）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 <code>UINT16_MAX</code> 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。</td>
</tr>
<tr>
<td align="left"><code>entryX</code></td>
<td align="left">列表节点</td>
<td align="left">不定</td>
<td align="left">压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</td>
</tr>
<tr>
<td align="left"><code>zlend</code></td>
<td align="left"><code>uint8_t</code></td>
<td align="left"><code>1</code> 字节</td>
<td align="left">特殊值 <code>0xFF</code> （十进制 <code>255</code> ），用于标记压缩列表的末端。</td>
</tr>
</tbody></table>
<p>图 7-2 展示了一个压缩列表示例：</p>
<ul>
<li>列表 <code>zlbytes</code> 属性的值为 <code>0x50</code> （十进制 <code>80</code>）， 表示压缩列表的总长为 <code>80</code> 字节。</li>
<li>列表 <code>zltail</code> 属性的值为 <code>0x3c</code> （十进制 <code>60</code>）， 这表示如果我们有一个指向压缩列表起始地址的指针 <code>p</code> ， 那么只要用指针 <code>p</code> 加上偏移量 <code>60</code> ， 就可以计算出表尾节点 <code>entry3</code> 的地址。</li>
<li>列表 <code>zllen</code> 属性的值为 <code>0x3</code> （十进制 <code>3</code>）， 表示压缩列表包含三个节点。</li>
</ul>
<p>![44](redis 数据结构对象.assets&#x2F;44.png)</p>
<p>图 7-3 展示了另一个压缩列表示例：</p>
<ul>
<li>列表 <code>zlbytes</code> 属性的值为 <code>0xd2</code> （十进制 <code>210</code>）， 表示压缩列表的总长为 <code>210</code> 字节。</li>
<li>列表 <code>zltail</code> 属性的值为 <code>0xb3</code> （十进制 <code>179</code>）， 这表示如果我们有一个指向压缩列表起始地址的指针 <code>p</code> ， 那么只要用指针 <code>p</code> 加上偏移量 <code>179</code> ， 就可以计算出表尾节点 <code>entry5</code> 的地址。</li>
<li>列表 <code>zllen</code> 属性的值为 <code>0x5</code> （十进制 <code>5</code>）， 表示压缩列表包含五个节点。</li>
</ul>
<p>![45](redis 数据结构对象.assets&#x2F;45.png)</p>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>前面说过， 每个节点的 <code>previous_entry_length</code> 属性都记录了前一个节点的长度：</p>
<ul>
<li>如果前一节点的长度小于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性需要用 <code>1</code> 字节长的空间来保存这个长度值。</li>
<li>如果前一节点的长度大于等于 <code>254</code> 字节， 那么 <code>previous_entry_length</code> 属性需要用 <code>5</code> 字节长的空间来保存这个长度值。</li>
</ul>
<p>现在， 考虑这样一种情况： 在一个压缩列表中， 有多个连续的、长度介于 <code>250</code> 字节到 <code>253</code> 字节之间的节点 <code>e1</code> 至 <code>eN</code> ， 如图 7-11 所示。</p>
<p>![46](redis 数据结构对象.assets&#x2F;46.png)</p>
<p>因为 <code>e1</code> 至 <code>eN</code> 的所有节点的长度都小于 <code>254</code> 字节， 所以记录这些节点的长度只需要 <code>1</code> 字节长的 <code>previous_entry_length</code> 属性， 换句话说， <code>e1</code> 至 <code>eN</code> 的所有节点的 <code>previous_entry_length</code> 属性都是 <code>1</code> 字节长的。</p>
<p>这时， 如果我们将一个长度大于等于 <code>254</code> 字节的新节点 <code>new</code> 设置为压缩列表的表头节点， 那么 <code>new</code> 将成为 <code>e1</code> 的前置节点， 如图 7-12 所示。</p>
<p>![46](redis 数据结构对象.assets&#x2F;47.png)</p>
<p>因为 <code>e1</code> 的 <code>previous_entry_length</code> 属性仅长 <code>1</code> 字节， 它没办法保存新节点 <code>new</code> 的长度， 所以程序将对压缩列表执行空间重分配操作， 并将 <code>e1</code> 节点的 <code>previous_entry_length</code> 属性从原来的 <code>1</code> 字节长扩展为 <code>5</code> 字节长。</p>
<p>现在， 麻烦的事情来了 —— <code>e1</code> 原本的长度介于 <code>250</code> 字节至 <code>253</code> 字节之间， 在为 <code>previous_entry_length</code> 属性新增四个字节的空间之后， <code>e1</code> 的长度就变成了介于 <code>254</code> 字节至 <code>257</code> 字节之间， 而这种长度使用 <code>1</code> 字节长的 <code>previous_entry_length</code> 属性是没办法保存的。</p>
<p>因此， 为了让 <code>e2</code> 的 <code>previous_entry_length</code> 属性可以记录下 <code>e1</code> 的长度， 程序需要再次对压缩列表执行空间重分配操作， 并将 <code>e2</code> 节点的 <code>previous_entry_length</code> 属性从原来的 <code>1</code> 字节长扩展为 <code>5</code> 字节长。</p>
<p>正如扩展 <code>e1</code> 引发了对 <code>e2</code> 的扩展一样， 扩展 <code>e2</code> 也会引发对 <code>e3</code> 的扩展， 而扩展 <code>e3</code> 又会引发对 <code>e4</code> 的扩展……为了让每个节点的 <code>previous_entry_length</code> 属性都符合压缩列表对节点的要求， 程序需要不断地对压缩列表执行空间重分配操作， 直到 <code>eN</code> 为止。</p>
<p>Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）， 图 7-13 展示了这一过程。</p>
<p>![47](redis 数据结构对象.assets&#x2F;48.png)</p>
<p>除了添加新节点可能会引发连锁更新之外， 删除节点也可能会引发连锁更新。</p>
<p>考虑图 7-14 所示的压缩列表， 如果 <code>e1</code> 至 <code>eN</code> 都是大小介于 <code>250</code> 字节至 <code>253</code> 字节的节点， <code>big</code> 节点的长度大于等于 <code>254</code> 字节（需要 <code>5</code> 字节的 <code>previous_entry_length</code> 来保存）， 而 <code>small</code> 节点的长度小于 <code>254</code> 字节（只需要 <code>1</code> 字节的 <code>previous_entry_length</code> 来保存）， 那么当我们将 <code>small</code> 节点从压缩列表中删除之后， 为了让 <code>e1</code> 的 <code>previous_entry_length</code> 属性可以记录 <code>big</code> 节点的长度， 程序将扩展 <code>e1</code> 的空间， 并由此引发之后的连锁更新。</p>
<p>![48](redis 数据结构对象.assets&#x2F;48.png)</p>
<p>因为连锁更新在最坏情况下需要对压缩列表执行 <code>N</code> 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的最坏复杂度为 O(N^2) 。</p>
<p>要注意的是， 尽管连锁更新的复杂度较高， 但它真正造成性能问题的几率是很低的：</p>
<ul>
<li>首先， 压缩列表里要恰好有多个连续的、长度介于 <code>250</code> 字节至 <code>253</code> 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；</li>
<li>其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；</li>
</ul>
<p>因为以上原因， <code>ziplistPush</code> 等命令的平均复杂度仅为 O(N) ， 在实际中， 我们可以放心地使用这些函数， 而不必担心连锁更新会影响压缩列表的性能。</p>
<p>![49](redis 数据结构对象.assets&#x2F;49.png)</p>
<h2 id="压缩列表-API"><a href="#压缩列表-API" class="headerlink" title="压缩列表 API"></a>压缩列表 API</h2><p>表 7-4 压缩列表 API</p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">作用</th>
<th align="left">算法复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ziplistNew</code></td>
<td align="left">创建一个新的压缩列表。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>ziplistPush</code></td>
<td align="left">创建一个包含给定值的新节点， 并将这个新节点添加到压缩列表的表头或者表尾。</td>
<td align="left">平均 O(N) ，最坏 O(N^2) 。</td>
</tr>
<tr>
<td align="left"><code>ziplistInsert</code></td>
<td align="left">将包含给定值的新节点插入到给定节点之后。</td>
<td align="left">平均 O(N) ，最坏 O(N^2) 。</td>
</tr>
<tr>
<td align="left"><code>ziplistIndex</code></td>
<td align="left">返回压缩列表给定索引上的节点。</td>
<td align="left">O(N)</td>
</tr>
<tr>
<td align="left"><code>ziplistFind</code></td>
<td align="left">在压缩列表中查找并返回包含了给定值的节点。</td>
<td align="left">因为节点的值可能是一个字节数组， 所以检查节点值和给定值是否相同的复杂度为 O(N) ， 而查找整个列表的复杂度则为 O(N^2) 。</td>
</tr>
<tr>
<td align="left"><code>ziplistNext</code></td>
<td align="left">返回给定节点的下一个节点。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>ziplistPrev</code></td>
<td align="left">返回给定节点的前一个节点。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>ziplistGet</code></td>
<td align="left">获取给定节点所保存的值。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>ziplistDelete</code></td>
<td align="left">从压缩列表中删除给定的节点。</td>
<td align="left">平均 O(N) ，最坏 O(N^2) 。</td>
</tr>
<tr>
<td align="left"><code>ziplistDeleteRange</code></td>
<td align="left">删除压缩列表在给定索引上的连续多个节点。</td>
<td align="left">平均 O(N) ，最坏 O(N^2) 。</td>
</tr>
<tr>
<td align="left"><code>ziplistBlobLen</code></td>
<td align="left">返回压缩列表目前占用的内存字节数。</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left"><code>ziplistLen</code></td>
<td align="left">返回压缩列表目前包含的节点数量。</td>
<td align="left">节点数量小于 <code>65535</code> 时 O(1) ， 大于 <code>65535</code> 时 O(N) 。</td>
</tr>
</tbody></table>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li>
<li>压缩列表被用作列表键和哈希键的底层实现之一。</li>
<li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li>
<li>添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发连锁更新操作， 但这种操作出现的几率并不高。</li>
</ul>
<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>在前面的数个章节里， 我们陆续介绍了 Redis 用到的所有主要数据结构， 比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合， 等等。</p>
<p>Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是基于这些数据结构创建了一个对象系统， 这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</p>
<p>通过这五种不同类型的对象， Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。 使用对象的另一个好处是， 我们可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。</p>
<p>除此之外， Redis 的对象系统还实现了基于引用计数技术的内存回收机制： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放； 另外， Redis 还通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。</p>
<p>最后， Redis 的对象带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 <code>maxmemory</code> 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。</p>
<h2 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码"></a>对象的类型与编码</h2><p>Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p>
<p>举个例子， 以下 SET 命令在数据库中创建了一个新的键值对， 其中键值对的键是一个包含了字符串值 <code>&quot;msg&quot;</code> 的对象， 而键值对的值则是一个包含了字符串值 <code>&quot;hello world&quot;</code> 的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>Redis 中的每个对象都由一个 <code>redisObject</code> 结构表示， 该结构中和保存数据有关的三个属性分别是 <code>type</code> 属性、 <code>encoding</code> 属性和 <code>ptr</code> 属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>





<h3 id="1-类型"><a href="#1-类型" class="headerlink" title="1. 类型"></a>1. 类型</h3><p>对象的 <code>type</code> 属性记录了对象的类型， 这个属性的值可以是表 8-1 列出的常量的其中一个。</p>
<hr>
<p>表 8-1 对象的类型</p>
<table>
<thead>
<tr>
<th>类型常量</th>
<th>对象的名称</th>
</tr>
</thead>
<tbody><tr>
<td><code>REDIS_STRING</code></td>
<td>字符串对象</td>
</tr>
<tr>
<td><code>REDIS_LIST</code></td>
<td>列表对象</td>
</tr>
<tr>
<td><code>REDIS_HASH</code></td>
<td>哈希对象</td>
</tr>
<tr>
<td><code>REDIS_SET</code></td>
<td>集合对象</td>
</tr>
<tr>
<td><code>REDIS_ZSET</code></td>
<td>有序集合对象</td>
</tr>
</tbody></table>
<hr>
<p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种， 因此：</p>
<ul>
<li>当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；</li>
<li>当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”，</li>
</ul>
<p>诸如此类。</p>
<p>TYPE 命令的实现方式也与此类似， 当我们对一个数据库键执行 TYPE 命令时， 命令返回的结果为数据库键对应的值对象的类型， 而不是键对象的类型：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键为字符串对象，值为字符串对象</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET msg <span class="string">&quot;hello world&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">TYPE msg</span></span><br><span class="line">string</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键为字符串对象，值为列表对象</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">RPUSH numbers 1 3 5</span></span><br><span class="line">(integer) 6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">TYPE numbers</span></span><br><span class="line">list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键为字符串对象，值为哈希对象</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">HMSET profile name Tome age 25 career Programmer</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">TYPE profile</span></span><br><span class="line">hash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键为字符串对象，值为集合对象</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SADD fruits apple banana cherry</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">TYPE fruits</span></span><br><span class="line">set</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键为字符串对象，值为有序集合对象</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">ZADD price 8.5 apple 5.0 banana 6.0 cherry</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">TYPE price</span></span><br><span class="line">zset</span><br></pre></td></tr></table></figure>

<p>表 8-2 列出了 TYPE 命令在面对不同类型的值对象时所产生的输出。</p>
<hr>
<p>表 8-2 不同类型值对象的 TYPE 命令输出</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>对象 <code>type</code> 属性的值</th>
<th>TYPE 命令的输出</th>
</tr>
</thead>
<tbody><tr>
<td>字符串对象</td>
<td><code>REDIS_STRING</code></td>
<td><code>&quot;string&quot;</code></td>
</tr>
<tr>
<td>列表对象</td>
<td><code>REDIS_LIST</code></td>
<td><code>&quot;list&quot;</code></td>
</tr>
<tr>
<td>哈希对象</td>
<td><code>REDIS_HASH</code></td>
<td><code>&quot;hash&quot;</code></td>
</tr>
<tr>
<td>集合对象</td>
<td><code>REDIS_SET</code></td>
<td><code>&quot;set&quot;</code></td>
</tr>
<tr>
<td>有序集合对象</td>
<td><code>REDIS_ZSET</code></td>
<td><code>&quot;zset&quot;</code></td>
</tr>
</tbody></table>
<h3 id="2-编码和底层实现"><a href="#2-编码和底层实现" class="headerlink" title="2. 编码和底层实现"></a>2. 编码和底层实现</h3><p>对象的 <code>ptr</code> 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 <code>encoding</code> 属性决定。</p>
<p><code>encoding</code> 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现， 这个属性的值可以是表 8-3 列出的常量的其中一个。</p>
<hr>
<p>表 8-3 对象的编码</p>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody><tr>
<td><code>REDIS_ENCODING_INT</code></td>
<td><code>long</code> 类型的整数</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_EMBSTR</code></td>
<td><code>embstr</code> 编码的简单动态字符串</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_RAW</code></td>
<td>简单动态字符串</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_HT</code></td>
<td>字典</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td>双端链表</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>压缩列表</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_INTSET</code></td>
<td>整数集合</td>
</tr>
<tr>
<td><code>REDIS_ENCODING_SKIPLIST</code></td>
<td>跳跃表和字典</td>
</tr>
</tbody></table>
<hr>
<p>每种类型的对象都至少使用了两种不同的编码， 表 8-4 列出了每种类型的对象可以使用的编码。</p>
<hr>
<p>表 8-4 不同类型和编码的对象</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody><tr>
<td><code>REDIS_STRING</code></td>
<td><code>REDIS_ENCODING_INT</code></td>
<td>使用整数值实现的字符串对象。</td>
</tr>
<tr>
<td><code>REDIS_STRING</code></td>
<td><code>REDIS_ENCODING_EMBSTR</code></td>
<td>使用 <code>embstr</code> 编码的简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td><code>REDIS_STRING</code></td>
<td><code>REDIS_ENCODING_RAW</code></td>
<td>使用简单动态字符串实现的字符串对象。</td>
</tr>
<tr>
<td><code>REDIS_LIST</code></td>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>使用压缩列表实现的列表对象。</td>
</tr>
<tr>
<td><code>REDIS_LIST</code></td>
<td><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td>使用双端链表实现的列表对象。</td>
</tr>
<tr>
<td><code>REDIS_HASH</code></td>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>使用压缩列表实现的哈希对象。</td>
</tr>
<tr>
<td><code>REDIS_HASH</code></td>
<td><code>REDIS_ENCODING_HT</code></td>
<td>使用字典实现的哈希对象。</td>
</tr>
<tr>
<td><code>REDIS_SET</code></td>
<td><code>REDIS_ENCODING_INTSET</code></td>
<td>使用整数集合实现的集合对象。</td>
</tr>
<tr>
<td><code>REDIS_SET</code></td>
<td><code>REDIS_ENCODING_HT</code></td>
<td>使用字典实现的集合对象。</td>
</tr>
<tr>
<td><code>REDIS_ZSET</code></td>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td>使用压缩列表实现的有序集合对象。</td>
</tr>
<tr>
<td><code>REDIS_ZSET</code></td>
<td><code>REDIS_ENCODING_SKIPLIST</code></td>
<td>使用跳跃表和字典实现的有序集合对象。</td>
</tr>
</tbody></table>
<hr>
<p>使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET msg <span class="string">&quot;hello wrold&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING msg</span></span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET story <span class="string">&quot;long long long long long long ago ...&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING story</span></span><br><span class="line">&quot;raw&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SADD numbers 1 3 5</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING numbers</span></span><br><span class="line">&quot;intset&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SADD numbers <span class="string">&quot;seven&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING numbers</span></span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<p>表 8-5 列出了不同编码的对象所对应的 OBJECT ENCODING 命令输出。</p>
<hr>
<p>表 8-5 OBJECT ENCODING 对不同编码的输出</p>
<table>
<thead>
<tr>
<th>对象所使用的底层数据结构</th>
<th>编码常量</th>
<th>OBJECT ENCODING 命令输出</th>
</tr>
</thead>
<tbody><tr>
<td>整数</td>
<td><code>REDIS_ENCODING_INT</code></td>
<td><code>&quot;int&quot;</code></td>
</tr>
<tr>
<td><code>embstr</code> 编码的简单动态字符串（SDS）</td>
<td><code>REDIS_ENCODING_EMBSTR</code></td>
<td><code>&quot;embstr&quot;</code></td>
</tr>
<tr>
<td>简单动态字符串</td>
<td><code>REDIS_ENCODING_RAW</code></td>
<td><code>&quot;raw&quot;</code></td>
</tr>
<tr>
<td>字典</td>
<td><code>REDIS_ENCODING_HT</code></td>
<td><code>&quot;hashtable&quot;</code></td>
</tr>
<tr>
<td>双端链表</td>
<td><code>REDIS_ENCODING_LINKEDLIST</code></td>
<td><code>&quot;linkedlist&quot;</code></td>
</tr>
<tr>
<td>压缩列表</td>
<td><code>REDIS_ENCODING_ZIPLIST</code></td>
<td><code>&quot;ziplist&quot;</code></td>
</tr>
<tr>
<td>整数集合</td>
<td><code>REDIS_ENCODING_INTSET</code></td>
<td><code>&quot;intset&quot;</code></td>
</tr>
<tr>
<td>跳跃表和字典</td>
<td><code>REDIS_ENCODING_SKIPLIST</code></td>
<td><code>&quot;skiplist&quot;</code></td>
</tr>
</tbody></table>
<hr>
<p>通过 <code>encoding</code> 属性来设定对象所使用的编码， 而不是为特定类型的对象关联一种固定的编码， 极大地提升了 Redis 的灵活性和效率， 因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率。</p>
<p>举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：</p>
<ul>
<li>因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</li>
<li>随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；</li>
</ul>
<p>其他类型的对象也会通过使用多种不同的编码来进行类似的优化。</p>
<p>在接下来的内容中， 我们将分别介绍 Redis 中的五种不同类型的对象， 说明这些对象底层所使用的编码方式， 列出对象从一种编码转换成另一种编码所需的条件， 以及同一个命令在多种不同编码上的实现方法。</p>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>字符串对象的编码可以是 <code>int</code> 、 <code>raw</code> 或者 <code>embstr</code> 。</p>
<p>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 <code>long</code> 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 <code>ptr</code> 属性里面（将 <code>void*</code> 转换成 <code>long</code> ）， 并将字符串对象的编码设置为 <code>int</code> 。</p>
<p>举个例子， 如果我们执行以下 SET 命令， 那么服务器将创建一个如图 8-1 所示的 <code>int</code> 编码的字符串对象作为 <code>number</code> 键的值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET number 10086</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING number</span></span><br><span class="line">&quot;int&quot;</span><br></pre></td></tr></table></figure>

<p>![53](redis 数据结构对象.assets&#x2F;50.png)</p>
<p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 <code>39</code> 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 <code>raw</code> 。</p>
<p>举个例子， 如果我们执行以下命令， 那么服务器将创建一个如图 8-2 所示的 <code>raw</code> 编码的字符串对象作为 <code>story</code> 键的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET story &quot;Long, long, long ago there lived a king ...&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; STRLEN story</span><br><span class="line">(integer) 43</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING story</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>

<p>![53](redis 数据结构对象.assets&#x2F;51.png)</p>
<p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 <code>39</code> 字节， 那么字符串对象将使用 <code>embstr</code> 编码的方式来保存这个字符串值。</p>
<p><code>embstr</code> 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 <code>raw</code> 编码一样， 都使用 <code>redisObject</code> 结构和 <code>sdshdr</code> 结构来表示字符串对象， 但 <code>raw</code> 编码会调用两次内存分配函数来分别创建 <code>redisObject</code> 结构和 <code>sdshdr</code> 结构， 而 <code>embstr</code> 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 <code>redisObject</code> 和 <code>sdshdr</code> 两个结构， 如图 8-3 所示。</p>
<p>![53](redis 数据结构对象.assets&#x2F;53.png)</p>
<p><code>embstr</code> 编码的字符串对象在执行命令时， 产生的效果和 <code>raw</code> 编码的字符串对象执行命令时产生的效果是相同的， 但使用 <code>embstr</code> 编码的字符串对象来保存短字符串值有以下好处：</p>
<ol>
<li><code>embstr</code> 编码将创建字符串对象所需的内存分配次数从 <code>raw</code> 编码的两次降低为一次。</li>
<li>释放 <code>embstr</code> 编码的字符串对象只需要调用一次内存释放函数， 而释放 <code>raw</code> 编码的字符串对象需要调用两次内存释放函数。</li>
<li>因为 <code>embstr</code> 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 <code>raw</code> 编码的字符串对象能够更好地利用缓存带来的优势。</li>
</ol>
<p>作为例子， 以下命令创建了一个 <code>embstr</code> 编码的字符串对象作为 <code>msg</code> 键的值， 值对象的样子如图 8-4 所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>

<p>![54](redis 数据结构对象.assets&#x2F;54.png)</p>
<p>最后要说的是， 可以用 <code>long double</code> 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。</p>
<p>举个例子， 执行以下代码将创建一个包含 <code>3.14</code> 的字符串表示 <code>&quot;3.14&quot;</code> 的字符串对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET pi 3.14</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING pi</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>

<p>在有需要的时候， 程序会将保存在字符串对象里面的字符串值转换回浮点数值， 执行某些操作， 然后再将执行操作所得的浮点数值转换回字符串值， 并继续保存在字符串对象里面。</p>
<p>举个例子， 如果我们执行以下代码的话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; INCRBYFLOAT pi 2.0</span><br><span class="line">&quot;5.14&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING pi</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure>

<p>那么程序首先会取出字符串对象里面保存的字符串值 <code>&quot;3.14&quot;</code> ， 将它转换回浮点数值 <code>3.14</code> ， 然后把 <code>3.14</code> 和 <code>2.0</code> 相加得出的值 <code>5.14</code> 转换成字符串 <code>&quot;5.14&quot;</code> ， 并将这个 <code>&quot;5.14&quot;</code> 保存到字符串对象里面。</p>
<p>表 8-6 总结并列出了字符串对象保存各种不同类型的值所使用的编码方式。</p>
<hr>
<p>表 8-6 字符串对象保存各类型值的编码方式</p>
<table>
<thead>
<tr>
<th>值</th>
<th>编码</th>
</tr>
</thead>
<tbody><tr>
<td>可以用 <code>long</code> 类型保存的整数。</td>
<td><code>int</code></td>
</tr>
<tr>
<td>可以用 <code>long double</code> 类型保存的浮点数。</td>
<td><code>embstr</code> 或者 <code>raw</code></td>
</tr>
<tr>
<td>字符串值， 或者因为长度太大而没办法用 <code>long</code> 类型表示的整数， 又或者因为长度太大而没办法用 <code>long double</code> 类型表示的浮点数。</td>
<td><code>embstr</code> 或者 <code>raw</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h3><p><code>int</code> 编码的字符串对象和 <code>embstr</code> 编码的字符串对象在条件满足的情况下， 会被转换为 <code>raw</code> 编码的字符串对象。</p>
<p>对于 <code>int</code> 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 <code>int</code> 变为 <code>raw</code> 。</p>
<p>在下面的示例中， 我们通过 APPEND 命令， 向一个保存整数值的字符串对象追加了一个字符串值， 因为追加操作只能对字符串值执行， 所以程序会先将之前保存的整数值 <code>10086</code> 转换为字符串值 <code>&quot;10086&quot;</code> ， 然后再执行追加操作， 操作的执行结果就是一个 <code>raw</code> 编码的、保存了字符串值的字符串对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET number 10086</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING number</span><br><span class="line">&quot;int&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND number &quot; is a good number!&quot;</span><br><span class="line">(integer) 23</span><br><span class="line"></span><br><span class="line">redis&gt; GET number</span><br><span class="line">&quot;10086 is a good number!&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING number</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>

<p>另外， 因为 Redis 没有为 <code>embstr</code> 编码的字符串对象编写任何相应的修改程序 （只有 <code>int</code> 编码的字符串对象和 <code>raw</code> 编码的字符串对象有这些程序）， 所以 <code>embstr</code> 编码的字符串对象实际上是只读的： 当我们对 <code>embstr</code> 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 <code>embstr</code> 转换成 <code>raw</code> ， 然后再执行修改命令； 因为这个原因， <code>embstr</code> 编码的字符串对象在执行修改命令之后， 总会变成一个 <code>raw</code> 编码的字符串对象。</p>
<p>以下代码展示了一个 <code>embstr</code> 编码的字符串对象在执行 APPEND 命令之后， 对象的编码从 <code>embstr</code> 变为 <code>raw</code> 的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line">&quot;embstr&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND msg &quot; again!&quot;</span><br><span class="line">(integer) 18</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line">&quot;raw&quot;</span><br></pre></td></tr></table></figure>







<h3 id="字符串命令的实现"><a href="#字符串命令的实现" class="headerlink" title="字符串命令的实现"></a>字符串命令的实现</h3><p>因为字符串键的值为字符串对象， 所以用于字符串键的所有命令都是针对字符串对象来构建的， 表 8-7 列举了其中一部分字符串命令， 以及这些命令在不同编码的字符串对象下的实现方法。</p>
<hr>
<p>表 8-7 字符串命令的实现</p>
<table>
<thead>
<tr>
<th>命令</th>
<th><code>int</code> 编码的实现方法</th>
<th><code>embstr</code> 编码的实现方法</th>
<th><code>raw</code> 编码的实现方法</th>
</tr>
</thead>
<tbody><tr>
<td>SET</td>
<td>使用 <code>int</code> 编码保存值。</td>
<td>使用 <code>embstr</code> 编码保存值。</td>
<td>使用 <code>raw</code> 编码保存值。</td>
</tr>
<tr>
<td>GET</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。</td>
<td>直接向客户端返回字符串值。</td>
<td>直接向客户端返回字符串值。</td>
</tr>
<tr>
<td>APPEND</td>
<td>将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code> 编码的方式执行此操作。</td>
<td>将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code> 编码的方式执行此操作。</td>
<td>调用 <code>sdscatlen</code> 函数， 将给定字符串追加到现有字符串的末尾。</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>取出整数值并将其转换成 <code>long double</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。</td>
<td>取出字符串值并尝试将其转换成 <code>long double</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>
<td>取出字符串值并尝试将其转换成 <code>long double</code> 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。</td>
</tr>
<tr>
<td>INCRBY</td>
<td>对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。</td>
<td><code>embstr</code> 编码不能执行此命令， 向客户端返回一个错误。</td>
<td><code>raw</code> 编码不能执行此命令， 向客户端返回一个错误。</td>
</tr>
<tr>
<td>DECRBY</td>
<td>对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。</td>
<td><code>embstr</code> 编码不能执行此命令， 向客户端返回一个错误。</td>
<td><code>raw</code> 编码不能执行此命令， 向客户端返回一个错误。</td>
</tr>
<tr>
<td>STRLEN</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。</td>
<td>调用 <code>sdslen</code> 函数， 返回字符串的长度。</td>
<td>调用 <code>sdslen</code> 函数， 返回字符串的长度。</td>
</tr>
<tr>
<td>SETRANGE</td>
<td>将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code> 编码的方式执行此命令。</td>
<td>将对象转换成 <code>raw</code> 编码， 然后按 <code>raw</code> 编码的方式执行此命令。</td>
<td>将字符串特定索引上的值设置为给定的字符。</td>
</tr>
<tr>
<td>GETRANGE</td>
<td>拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。</td>
<td>直接取出并返回字符串指定索引上的字符。</td>
<td>直接取出并返回字符串指定索引上的字符。</td>
</tr>
</tbody></table>
<h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p>列表对象的编码可以是 <code>ziplist</code> 或者 <code>linkedlist</code> 。</p>
<p><code>ziplist</code> 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素。</p>
<p>举个例子， 如果我们执行以下 RPUSH 命令， 那么服务器将创建一个列表对象作为 <code>numbers</code> 键的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH numbers 1 &quot;three&quot; 5</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>如果 <code>numbers</code> 键的值对象使用的是 <code>ziplist</code> 编码， 这个这个值对象将会是图 8-5 所展示的样子。</p>
<p>![58](redis 数据结构对象.assets&#x2F;55.png)</p>
<p>另一方面， <code>linkedlist</code> 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素。</p>
<p>举个例子， 如果前面所说的 <code>numbers</code> 键创建的列表对象使用的不是 <code>ziplist</code> 编码， 而是 <code>linkedlist</code> 编码， 那么 <code>numbers</code> 键的值对象将是图 8-6 所示的样子。</p>
<p>![58](redis 数据结构对象.assets&#x2F;56.png)</p>
<p>注意， <code>linkedlist</code> 编码的列表对象在底层的双端链表结构中包含了多个字符串对象， 这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现， 字符串对象是 Redis 五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。</p>
<p>注意</p>
<p>为了简化字符串对象的表示， 我们在图 8-6 使用了一个带有 <code>StringObject</code> 字样的格子来表示一个字符串对象， 而 <code>StringObject</code> 字样下面的是字符串对象所保存的值。</p>
<p>比如说， 图 8-7 代表的就是一个包含了字符串值 <code>&quot;three&quot;</code> 的字符串对象， 它是 8-8 的简化表示。</p>
<p>![58](redis 数据结构对象.assets&#x2F;57.png)</p>
<p>![58](redis 数据结构对象.assets&#x2F;58.png)</p>
<p>本书接下来的内容将继续沿用这一简化表示。</p>
<h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><p>当列表对象可以同时满足以下两个条件时， 列表对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于 <code>64</code> 字节；</li>
<li>列表对象保存的元素数量小于 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的列表对象需要使用 <code>linkedlist</code> 编码。</p>
<p>注意</p>
<p>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 <code>list-max-ziplist-value</code> 选项和 <code>list-max-ziplist-entries</code> 选项的说明。</p>
<p>对于使用 <code>ziplist</code> 编码的列表对象来说， 当使用 <code>ziplist</code> 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面， 对象的编码也会从 <code>ziplist</code> 变为 <code>linkedlist</code> 。</p>
<p>以下代码展示了列表对象因为保存了长度太大的元素而进行编码转换的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有元素的长度都小于 64 字节</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">RPUSH blah <span class="string">&quot;hello&quot;</span> <span class="string">&quot;world&quot;</span> <span class="string">&quot;again&quot;</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING blah</span></span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个 65 字节长的元素推入列表对象中</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">RPUSH blah <span class="string">&quot;wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww&quot;</span></span></span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编码已改变</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING blah</span></span><br><span class="line">&quot;linkedlist&quot;</span><br></pre></td></tr></table></figure>

<p>除此之外， 以下代码展示了列表对象因为保存的元素数量过多而进行编码转换的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列表对象包含 512 个元素</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">EVAL <span class="string">&quot;for i=1,512 do redis.call(&#x27;RPUSH&#x27;, KEYS[1], i) end&quot;</span> 1 <span class="string">&quot;integers&quot;</span></span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">LLEN integers</span></span><br><span class="line">(integer) 512</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING integers</span></span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再向列表对象推入一个新元素，使得对象保存的元素数量达到 513 个</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">RPUSH integers 513</span></span><br><span class="line">(integer) 513</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编码已改变</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT ENCODING integers</span></span><br><span class="line">&quot;linkedlist&quot;</span><br></pre></td></tr></table></figure>









<h3 id="列表命令的实现"><a href="#列表命令的实现" class="headerlink" title="列表命令的实现"></a>列表命令的实现</h3><p>因为列表键的值为列表对象， 所以用于列表键的所有命令都是针对列表对象来构建的， 表 8-8 列出了其中一部分列表键命令， 以及这些命令在不同编码的列表对象下的实现方法。</p>
<hr>
<p>表 8-8 列表命令的实现</p>
<table>
<thead>
<tr>
<th>命令</th>
<th><code>ziplist</code> 编码的实现方法</th>
<th><code>linkedlist</code> 编码的实现方法</th>
</tr>
</thead>
<tbody><tr>
<td>LPUSH</td>
<td>调用 <code>ziplistPush</code> 函数， 将新元素推入到压缩列表的表头。</td>
<td>调用 <code>listAddNodeHead</code> 函数， 将新元素推入到双端链表的表头。</td>
</tr>
<tr>
<td>RPUSH</td>
<td>调用 <code>ziplistPush</code> 函数， 将新元素推入到压缩列表的表尾。</td>
<td>调用 <code>listAddNodeTail</code> 函数， 将新元素推入到双端链表的表尾。</td>
</tr>
<tr>
<td>LPOP</td>
<td>调用 <code>ziplistIndex</code> 函数定位压缩列表的表头节点， 在向用户返回节点所保存的元素之后， 调用 <code>ziplistDelete</code> 函数删除表头节点。</td>
<td>调用 <code>listFirst</code> 函数定位双端链表的表头节点， 在向用户返回节点所保存的元素之后， 调用 <code>listDelNode</code> 函数删除表头节点。</td>
</tr>
<tr>
<td>RPOP</td>
<td>调用 <code>ziplistIndex</code> 函数定位压缩列表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 <code>ziplistDelete</code> 函数删除表尾节点。</td>
<td>调用 <code>listLast</code> 函数定位双端链表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 <code>listDelNode</code> 函数删除表尾节点。</td>
</tr>
<tr>
<td>LINDEX</td>
<td>调用 <code>ziplistIndex</code> 函数定位压缩列表中的指定节点， 然后返回节点所保存的元素。</td>
<td>调用 <code>listIndex</code> 函数定位双端链表中的指定节点， 然后返回节点所保存的元素。</td>
</tr>
<tr>
<td>LLEN</td>
<td>调用 <code>ziplistLen</code> 函数返回压缩列表的长度。</td>
<td>调用 <code>listLength</code> 函数返回双端链表的长度。</td>
</tr>
<tr>
<td>LINSERT</td>
<td>插入新节点到压缩列表的表头或者表尾时， 使用 <code>ziplistPush</code> 函数； 插入新节点到压缩列表的其他位置时， 使用 <code>ziplistInsert</code> 函数。</td>
<td>调用 <code>listInsertNode</code> 函数， 将新节点插入到双端链表的指定位置。</td>
</tr>
<tr>
<td>LREM</td>
<td>遍历压缩列表节点， 并调用 <code>ziplistDelete</code> 函数删除包含了给定元素的节点。</td>
<td>遍历双端链表节点， 并调用 <code>listDelNode</code> 函数删除包含了给定元素的节点。</td>
</tr>
<tr>
<td>LTRIM</td>
<td>调用 <code>ziplistDeleteRange</code> 函数， 删除压缩列表中所有不在指定索引范围内的节点。</td>
<td>遍历双端链表节点， 并调用 <code>listDelNode</code> 函数删除链表中所有不在指定索引范围内的节点。</td>
</tr>
<tr>
<td>LSET</td>
<td>调用 <code>ziplistDelete</code> 函数， 先删除压缩列表指定索引上的现有节点， 然后调用 <code>ziplistInsert</code> 函数， 将一个包含给定元素的新节点插入到相同索引上面。</td>
<td>调用 <code>listIndex</code> 函数， 定位到双端链表指定索引上的节点， 然后通过赋值操作更新节点的值。</td>
</tr>
</tbody></table>
<h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><p>哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code> 。</p>
<p><code>ziplist</code> 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：</p>
<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li>
</ul>
<p>举个例子， 如果我们执行以下 HSET 命令， 那么服务器将创建一个列表对象作为 <code>profile</code> 键的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; HSET profile name &quot;Tom&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET profile age 25</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; HSET profile career &quot;Programmer&quot;</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>如果 <code>profile</code> 键的值对象使用的是 <code>ziplist</code> 编码， 那么这个值对象将会是图 8-9 所示的样子， 其中对象所使用的压缩列表如图 8-10 所示。</p>
<p>![58](redis 数据结构对象.assets&#x2F;59.png)</p>
<p>![58](redis 数据结构对象.assets&#x2F;60.png)</p>
<p>另一方面， <code>hashtable</code> 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值。</li>
</ul>
<p>举个例子， 如果前面 <code>profile</code> 键创建的不是 <code>ziplist</code> 编码的哈希对象， 而是 <code>hashtable</code> 编码的哈希对象， 那么这个哈希对象应该会是图 8-11 所示的样子。</p>
<p>![58](redis 数据结构对象.assets&#x2F;61.png)</p>
<h3 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h3><p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 <code>64</code> 字节；</li>
<li>哈希对象保存的键值对数量小于 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的哈希对象需要使用 <code>hashtable</code> 编码。</p>
<p>注意</p>
<p>这两个条件的上限值是可以修改的， 具体请看配置文件中关于 <code>hash-max-ziplist-value</code> 选项和 <code>hash-max-ziplist-entries</code> 选项的说明。</p>
<p>对于使用 <code>ziplist</code> 编码的列表对象来说， 当使用 <code>ziplist</code> 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面， 对象的编码也会从 <code>ziplist</code> 变为 <code>hashtable</code> 。</p>
<p>以下代码展示了哈希对象因为键值对的键长度太大而引起编码转换的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 哈希对象只包含一个键和值都不超过 64 个字节的键值对</span><br><span class="line">redis&gt; HSET book name &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING book</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br><span class="line"># 向哈希对象添加一个新的键值对，键的长度为 66 字节</span><br><span class="line">redis&gt; HSET book long_long_long_long_long_long_long_long_long_long_long_description &quot;content&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 编码已改变</span><br><span class="line">redis&gt; OBJECT ENCODING book</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<p>除了键的长度太大会引起编码转换之外， 值的长度太大也会引起编码转换， 以下代码展示了这种情况的一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 哈希对象只包含一个键和值都不超过 64 个字节的键值对</span><br><span class="line">redis&gt; HSET blah greeting &quot;hello world&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING blah</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br><span class="line"># 向哈希对象添加一个新的键值对，值的长度为 68 字节</span><br><span class="line">redis&gt; HSET blah story &quot;many string ... many string ... many string ... many string ... many&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 编码已改变</span><br><span class="line">redis&gt; OBJECT ENCODING blah</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<p>最后， 以下代码展示了哈希对象因为包含的键值对数量过多而引起编码转换的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个包含 512 个键值对的哈希对象</span><br><span class="line">redis&gt; EVAL &quot;for i=1, 512 do redis.call(&#x27;HSET&#x27;, KEYS[1], i, i) end&quot; 1 &quot;numbers&quot;</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; HLEN numbers</span><br><span class="line">(integer) 512</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br><span class="line"># 再向哈希对象添加一个新的键值对，使得键值对的数量变成 513 个</span><br><span class="line">redis&gt; HMSET numbers &quot;key&quot; &quot;value&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; HLEN numbers</span><br><span class="line">(integer) 513</span><br><span class="line"></span><br><span class="line"># 编码改变</span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>







<h3 id="哈希命令的实现"><a href="#哈希命令的实现" class="headerlink" title="哈希命令的实现"></a>哈希命令的实现</h3><p>因为哈希键的值为哈希对象， 所以用于哈希键的所有命令都是针对哈希对象来构建的， 表 8-9 列出了其中一部分哈希键命令， 以及这些命令在不同编码的哈希对象下的实现方法。</p>
<hr>
<p>表 8-9 哈希命令的实现</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left"><code>ziplist</code> 编码实现方法</th>
<th align="left"><code>hashtable</code> 编码的实现方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HSET</td>
<td align="left">首先调用 <code>ziplistPush</code> 函数， 将键推入到压缩列表的表尾， 然后再次调用 <code>ziplistPush</code> 函数， 将值推入到压缩列表的表尾。</td>
<td align="left">调用 <code>dictAdd</code> 函数， 将新节点添加到字典里面。</td>
</tr>
<tr>
<td align="left">HGET</td>
<td align="left">首先调用 <code>ziplistFind</code> 函数， 在压缩列表中查找指定键所对应的节点， 然后调用 <code>ziplistNext</code> 函数， 将指针移动到键节点旁边的值节点， 最后返回值节点。</td>
<td align="left">调用 <code>dictFind</code> 函数， 在字典中查找给定键， 然后调用 <code>dictGetVal</code> 函数， 返回该键所对应的值。</td>
</tr>
<tr>
<td align="left">HEXISTS</td>
<td align="left">调用 <code>ziplistFind</code> 函数， 在压缩列表中查找指定键所对应的节点， 如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。</td>
<td align="left">调用 <code>dictFind</code> 函数， 在字典中查找给定键， 如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。</td>
</tr>
<tr>
<td align="left">HDEL</td>
<td align="left">调用 <code>ziplistFind</code> 函数， 在压缩列表中查找指定键所对应的节点， 然后将相应的键节点、 以及键节点旁边的值节点都删除掉。</td>
<td align="left">调用 <code>dictDelete</code> 函数， 将指定键所对应的键值对从字典中删除掉。</td>
</tr>
<tr>
<td align="left">HLEN</td>
<td align="left">调用 <code>ziplistLen</code> 函数， 取得压缩列表包含节点的总数量， 将这个数量除以 <code>2</code> ， 得出的结果就是压缩列表保存的键值对的数量。</td>
<td align="left">调用 <code>dictSize</code> 函数， 返回字典包含的键值对数量， 这个数量就是哈希对象包含的键值对数量。</td>
</tr>
<tr>
<td align="left">HGETALL</td>
<td align="left">遍历整个压缩列表， 用 <code>ziplistGet</code> 函数返回所有键和值（都是节点）。</td>
<td align="left">遍历整个字典， 用 <code>dictGetKey</code> 函数返回字典的键， 用 <code>dictGetVal</code> 函数返回字典的值。</td>
</tr>
</tbody></table>
<h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><p>集合对象的编码可以是 <code>intset</code> 或者 <code>hashtable</code> 。</p>
<p><code>intset</code> 编码的集合对象使用整数集合作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。</p>
<p>举个例子， 以下代码将创建一个如图 8-12 所示的 <code>intset</code> 编码集合对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD numbers 1 3 5</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>![58](redis 数据结构对象.assets&#x2F;62.png)</p>
<p>另一方面， <code>hashtable</code> 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 <code>NULL</code> 。</p>
<p>举个例子， 以下代码将创建一个如图 8-13 所示的 <code>hashtable</code> 编码集合对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>![58](redis 数据结构对象.assets&#x2F;63.png)</p>
<h3 id="编码的转换-1"><a href="#编码的转换-1" class="headerlink" title="编码的转换"></a>编码的转换</h3><p>当集合对象可以同时满足以下两个条件时， 对象使用 <code>intset</code> 编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 <code>512</code> 个；</li>
</ol>
<p>不能满足这两个条件的集合对象需要使用 <code>hashtable</code> 编码。</p>
<p>注意</p>
<p>第二个条件的上限值是可以修改的， 具体请看配置文件中关于 <code>set-max-intset-entries</code> 选项的说明。</p>
<p>对于使用 <code>intset</code> 编码的集合对象来说， 当使用 <code>intset</code> 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在整数集合中的所有元素都会被转移并保存到字典里面， 并且对象的编码也会从 <code>intset</code> 变为 <code>hashtable</code> 。</p>
<p>举个例子， 以下代码创建了一个只包含整数元素的集合对象， 该对象的编码为 <code>intset</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD numbers 1 3 5</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure>

<p>不过， 只要我们向这个只包含整数元素的集合对象添加一个字符串元素， 集合对象的编码转移操作就会被执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD numbers &quot;seven&quot;</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>

<p>除此之外， 如果我们创建一个包含 <code>512</code> 个整数元素的集合对象， 那么对象的编码应该会是 <code>intset</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL &quot;for i=1, 512 do redis.call(&#x27;SADD&#x27;, KEYS[1], i) end&quot; 1 integers</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; SCARD integers</span><br><span class="line">(integer) 512</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING integers</span><br><span class="line">&quot;intset&quot;</span><br></pre></td></tr></table></figure>

<p>但是， 只要我们再向集合添加一个新的整数元素， 使得这个集合的元素数量变成 <code>513</code> ， 那么对象的编码转换操作就会被执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SADD integers 10086</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; SCARD integers</span><br><span class="line">(integer) 513</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING integers</span><br><span class="line">&quot;hashtable&quot;</span><br></pre></td></tr></table></figure>







<h3 id="集合命令的实现"><a href="#集合命令的实现" class="headerlink" title="集合命令的实现"></a>集合命令的实现</h3><p>因为集合键的值为集合对象， 所以用于集合键的所有命令都是针对集合对象来构建的， 表 8-10 列出了其中一部分集合键命令， 以及这些命令在不同编码的集合对象下的实现方法。</p>
<hr>
<p>表 8-10 集合命令的实现方法</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left"><code>intset</code> 编码的实现方法</th>
<th align="left"><code>hashtable</code> 编码的实现方法</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SADD</td>
<td align="left">调用 <code>intsetAdd</code> 函数， 将所有新元素添加到整数集合里面。</td>
<td align="left">调用 <code>dictAdd</code> ， 以新元素为键， <code>NULL</code> 为值， 将键值对添加到字典里面。</td>
</tr>
<tr>
<td align="left">SCARD</td>
<td align="left">调用 <code>intsetLen</code> 函数， 返回整数集合所包含的元素数量， 这个数量就是集合对象所包含的元素数量。</td>
<td align="left">调用 <code>dictSize</code> 函数， 返回字典所包含的键值对数量， 这个数量就是集合对象所包含的元素数量。</td>
</tr>
<tr>
<td align="left">SISMEMBER</td>
<td align="left">调用 <code>intsetFind</code> 函数， 在整数集合中查找给定的元素， 如果找到了说明元素存在于集合， 没找到则说明元素不存在于集合。</td>
<td align="left">调用 <code>dictFind</code> 函数， 在字典的键中查找给定的元素， 如果找到了说明元素存在于集合， 没找到则说明元素不存在于集合。</td>
</tr>
<tr>
<td align="left">SMEMBERS</td>
<td align="left">遍历整个整数集合， 使用 <code>intsetGet</code> 函数返回集合元素。</td>
<td align="left">遍历整个字典， 使用 <code>dictGetKey</code> 函数返回字典的键作为集合元素。</td>
</tr>
<tr>
<td align="left">SRANDMEMBER</td>
<td align="left">调用 <code>intsetRandom</code> 函数， 从整数集合中随机返回一个元素。</td>
<td align="left">调用 <code>dictGetRandomKey</code> 函数， 从字典中随机返回一个字典键。</td>
</tr>
<tr>
<td align="left">SPOP</td>
<td align="left">调用 <code>intsetRandom</code> 函数， 从整数集合中随机取出一个元素， 在将这个随机元素返回给客户端之后， 调用 <code>intsetRemove</code> 函数， 将随机元素从整数集合中删除掉。</td>
<td align="left">调用 <code>dictGetRandomKey</code> 函数， 从字典中随机取出一个字典键， 在将这个随机字典键的值返回给客户端之后， 调用 <code>dictDelete</code> 函数， 从字典中删除随机字典键所对应的键值对。</td>
</tr>
<tr>
<td align="left">SREM</td>
<td align="left">调用 <code>intsetRemove</code> 函数， 从整数集合中删除所有给定的元素。</td>
<td align="left">调用 <code>dictDelete</code> 函数， 从字典中删除所有键为给定元素的键值对。</td>
</tr>
</tbody></table>
<h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><p>有序集合的编码可以是 <code>ziplist</code> 或者 <code>skiplist</code> 。</p>
<p><code>ziplist</code> 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。</p>
<p>举个例子， 如果我们执行以下 ZADD 命令， 那么服务器将创建一个有序集合对象作为 <code>price</code> 键的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; ZADD price 8.5 apple 5.0 banana 6.0 cherry</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>如果 <code>price</code> 键的值对象使用的是 <code>ziplist</code> 编码， 那么这个值对象将会是图 8-14 所示的样子， 而对象所使用的压缩列表则会是 8-15 所示的样子。</p>
<p>![58](redis 数据结构对象.assets&#x2F;64.png)</p>
<p>![58](redis 数据结构对象.assets&#x2F;65.png)</p>
<p><code>skiplist</code> 编码的有序集合对象使用 <code>zset</code> 结构作为底层实现， 一个 <code>zset</code> 结构同时包含一个字典和一个跳跃表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line"></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p><code>zset</code> 结构中的 <code>zsl</code> 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 <code>object</code> 属性保存了元素的成员， 而跳跃表节点的 <code>score</code> 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作， 比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。</p>
<p>除此之外， <code>zset</code> 结构中的 <code>dict</code> 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员， 而字典的值则保存了元素的分值。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性。</p>
<p>有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 <code>double</code> 类型的浮点数。 值得一提的是， 虽然 <code>zset</code> 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。</p>
<p>为什么有序集合需要同时使用跳跃表和字典来实现？</p>
<p>在理论上来说， 有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现， 但无论单独使用字典还是跳跃表， 在性能上对比起同时使用字典和跳跃表都会有所降低。</p>
<p>举个例子， 如果我们只使用字典来实现有序集合， 那么虽然以 O(1) 复杂度查找成员的分值这一特性会被保留， 但是， 因为字典以无序的方式来保存集合元素， 所以每次在执行范围型操作 —— 比如 ZRANK 、 ZRANGE 等命令时， 程序都需要对字典保存的所有元素进行排序， 完成这种排序需要至少 O(N \log N) 时间复杂度， 以及额外的 O(N) 内存空间 （因为要创建一个数组来保存排序后的元素）。</p>
<p>另一方面， 如果我们只使用跳跃表来实现有序集合， 那么跳跃表执行范围型操作的所有优点都会被保留， 但因为没有了字典， 所以根据成员查找分值这一操作的复杂度将从 O(1) 上升为 O(\log N) 。</p>
<p>因为以上原因， 为了让有序集合的查找和范围型操作都尽可能快地执行， Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。</p>
<p>举个例子， 如果前面 <code>price</code> 键创建的不是 <code>ziplist</code> 编码的有序集合对象， 而是 <code>skiplist</code> 编码的有序集合对象， 那么这个有序集合对象将会是图 8-16 所示的样子， 而对象所使用的 <code>zset</code> 结构将会是图 8-17 所示的样子。</p>
<p>![58](redis 数据结构对象.assets&#x2F;66.png)</p>
<p>![58](redis 数据结构对象.assets&#x2F;67.png)</p>
<p>注意</p>
<p>为了展示方便， 图 8-17 在字典和跳跃表中重复展示了各个元素的成员和分值， 但在实际中， 字典和跳跃表会共享元素的成员和分值， 所以并不会造成任何数据重复， 也不会因此而浪费任何内存。</p>
<h3 id="编码的转换-2"><a href="#编码的转换-2" class="headerlink" title="编码的转换"></a>编码的转换</h3><p>当有序集合对象可以同时满足以下两个条件时， 对象使用 <code>ziplist</code> 编码：</p>
<ol>
<li>有序集合保存的元素数量小于 <code>128</code> 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 <code>64</code> 字节；</li>
</ol>
<p>不能满足以上两个条件的有序集合对象将使用 <code>skiplist</code> 编码。</p>
<p>注意</p>
<p>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 <code>zset-max-ziplist-entries</code> 选项和 <code>zset-max-ziplist-value</code> 选项的说明。</p>
<p>对于使用 <code>ziplist</code> 编码的有序集合对象来说， 当使用 <code>ziplist</code> 编码所需的两个条件中的任意一个不能被满足时， 程序就会执行编码转换操作， 将原本储存在压缩列表里面的所有集合元素转移到 <code>zset</code> 结构里面， 并将对象的编码从 <code>ziplist</code> 改为 <code>skiplist</code> 。</p>
<p>以下代码展示了有序集合对象因为包含了过多元素而引发编码转换的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 对象包含了 128 个元素</span><br><span class="line">redis&gt; EVAL &quot;for i=1, 128 do redis.call(&#x27;ZADD&#x27;, KEYS[1], i, i) end&quot; 1 numbers</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">redis&gt; ZCARD numbers</span><br><span class="line">(integer) 128</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br><span class="line"># 再添加一个新元素</span><br><span class="line">redis&gt; ZADD numbers 3.14 pi</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 对象包含的元素数量变为 129 个</span><br><span class="line">redis&gt; ZCARD numbers</span><br><span class="line">(integer) 129</span><br><span class="line"></span><br><span class="line"># 编码已改变</span><br><span class="line">redis&gt; OBJECT ENCODING numbers</span><br><span class="line">&quot;skiplist&quot;</span><br></pre></td></tr></table></figure>

<p>以下代码则展示了有序集合对象因为元素的成员过长而引发编码转换的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 向有序集合添加一个成员只有三字节长的元素</span><br><span class="line">redis&gt; ZADD blah 1.0 www</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT ENCODING blah</span><br><span class="line">&quot;ziplist&quot;</span><br><span class="line"></span><br><span class="line"># 向有序集合添加一个成员为 66 字节长的元素</span><br><span class="line">redis&gt; ZADD blah 2.0 oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"># 编码已改变</span><br><span class="line">redis&gt; OBJECT ENCODING blah</span><br><span class="line">&quot;skiplist&quot;</span><br></pre></td></tr></table></figure>







<h3 id="有序集合命令的实现"><a href="#有序集合命令的实现" class="headerlink" title="有序集合命令的实现"></a>有序集合命令的实现</h3><p>因为有序集合键的值为有序集合对象， 所以用于有序集合键的所有命令都是针对有序集合对象来构建的， 表 8-11 列出了其中一部分有序集合键命令， 以及这些命令在不同编码的有序集合对象下的实现方法。</p>
<hr>
<p>表 8-11 有序集合命令的实现方法</p>
<table>
<thead>
<tr>
<th>命令</th>
<th><code>ziplist</code> 编码的实现方法</th>
<th><code>zset</code> 编码的实现方法</th>
</tr>
</thead>
<tbody><tr>
<td>ZADD</td>
<td>调用 <code>ziplistInsert</code> 函数， 将成员和分值作为两个节点分别插入到压缩列表。</td>
<td>先调用 <code>zslInsert</code> 函数， 将新元素添加到跳跃表， 然后调用 <code>dictAdd</code> 函数， 将新元素关联到字典。</td>
</tr>
<tr>
<td>ZCARD</td>
<td>调用 <code>ziplistLen</code> 函数， 获得压缩列表包含节点的数量， 将这个数量除以 <code>2</code> 得出集合元素的数量。</td>
<td>访问跳跃表数据结构的 <code>length</code> 属性， 直接返回集合元素的数量。</td>
</tr>
<tr>
<td>ZCOUNT</td>
<td>遍历压缩列表， 统计分值在给定范围内的节点的数量。</td>
<td>遍历跳跃表， 统计分值在给定范围内的节点的数量。</td>
</tr>
<tr>
<td>ZRANGE</td>
<td>从表头向表尾遍历压缩列表， 返回给定索引范围内的所有元素。</td>
<td>从表头向表尾遍历跳跃表， 返回给定索引范围内的所有元素。</td>
</tr>
<tr>
<td>ZREVRANGE</td>
<td>从表尾向表头遍历压缩列表， 返回给定索引范围内的所有元素。</td>
<td>从表尾向表头遍历跳跃表， 返回给定索引范围内的所有元素。</td>
</tr>
<tr>
<td>ZRANK</td>
<td>从表头向表尾遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。</td>
<td>从表头向表尾遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。</td>
</tr>
<tr>
<td>ZREVRANK</td>
<td>从表尾向表头遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。</td>
<td>从表尾向表头遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。</td>
</tr>
<tr>
<td>ZREM</td>
<td>遍历压缩列表， 删除所有包含给定成员的节点， 以及被删除成员节点旁边的分值节点。</td>
<td>遍历跳跃表， 删除所有包含了给定成员的跳跃表节点。 并在字典中解除被删除元素的成员和分值的关联。</td>
</tr>
<tr>
<td>ZSCORE</td>
<td>遍历压缩列表， 查找包含了给定成员的节点， 然后取出成员节点旁边的分值节点保存的元素分值。</td>
<td>直接从字典中取出给定成员的分值。</td>
</tr>
</tbody></table>
<h2 id="类型检查与命令多态"><a href="#类型检查与命令多态" class="headerlink" title="类型检查与命令多态"></a>类型检查与命令多态</h2><p>Redis 中用于操作键的命令基本上可以分为两种类型。</p>
<p>其中一种命令可以对任何类型的键执行， 比如说 DEL 命令、 EXPIRE 命令、 RENAME 命令、 TYPE 命令、 OBJECT 命令， 等等。</p>
<p>举个例子， 以下代码就展示了使用 DEL 命令来删除三种不同类型的键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 字符串键</span><br><span class="line">redis&gt; SET msg &quot;hello&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"># 列表键</span><br><span class="line">redis&gt; RPUSH numbers 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"># 集合键</span><br><span class="line">redis&gt; SADD fruits apple banana cherry</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; DEL msg</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; DEL numbers</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis&gt; DEL fruits</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>而另一种命令只能对特定类型的键执行， 比如说：</p>
<ul>
<li>SET 、 GET 、 APPEND 、 STRLEN 等命令只能对字符串键执行；</li>
<li>HDEL 、 HSET 、 HGET 、 HLEN 等命令只能对哈希键执行；</li>
<li>RPUSH 、 LPOP 、 LINSERT 、 LLEN 等命令只能对列表键执行；</li>
<li>SADD 、 SPOP 、 SINTER 、 SCARD 等命令只能对集合键执行；</li>
<li>ZADD 、 ZCARD 、 ZRANK 、 ZSCORE 等命令只能对有序集合键执行；</li>
</ul>
<p>诸如此类。</p>
<p>举个例子， 我们可以用 SET 命令创建一个字符串键， 然后用 GET 命令和 APPEND 命令操作这个键， 但如果我们试图对这个字符串键执行只有列表键才能执行的 LLEN 命令， 那么 Redis 将向我们返回一个类型错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello world&quot;</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET msg</span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; APPEND msg &quot; again!&quot;</span><br><span class="line">(integer) 18</span><br><span class="line"></span><br><span class="line">redis&gt; GET msg</span><br><span class="line">&quot;hello world again!&quot;</span><br><span class="line"></span><br><span class="line">redis&gt; LLEN msg</span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure>





<h3 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h3><p>从上面发生类型错误的代码示例可以看出， 为了确保只有指定类型的键可以执行某些特定的命令， 在执行一个类型特定的命令之前， Redis 会先检查输入键的类型是否正确， 然后再决定是否执行给定的命令。</p>
<p>类型特定命令所进行的类型检查是通过 <code>redisObject</code> 结构的 <code>type</code> 属性来实现的：</p>
<ul>
<li>在执行一个类型特定命令之前， 服务器会先检查输入数据库键的值对象是否为执行命令所需的类型， 如果是的话， 服务器就对键执行指定的命令；</li>
<li>否则， 服务器将拒绝执行命令， 并向客户端返回一个类型错误。</li>
</ul>
<p>举个例子， 对于 LLEN 命令来说：</p>
<ul>
<li>在执行 LLEN 命令之前， 服务器会先检查输入数据库键的值对象是否为列表类型， 也即是， 检查值对象 <code>redisObject</code> 结构 <code>type</code> 属性的值是否为 <code>REDIS_LIST</code> ， 如果是的话， 服务器就对键执行 LLEN 命令；</li>
<li>否则的话， 服务器就拒绝执行命令并向客户端返回一个类型错误；</li>
</ul>
<p>图 8-18 展示了这一类型检查过程。</p>
<p>![58](redis 数据结构对象.assets&#x2F;68.png)</p>
<p>其他类型特定命令的类型检查过程也和这里展示的 LLEN 命令的类型检查过程类似。</p>
<h2 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h2><p>Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外， 还会根据值对象的编码方式， 选择正确的命令实现代码来执行命令。</p>
<p>举个例子， 在前面介绍列表对象的编码时我们说过， 列表对象有 <code>ziplist</code> 和 <code>linkedlist</code> 两种编码可用， 其中前者使用压缩列表 API 来实现列表命令， 而后者则使用双端链表 API 来实现列表命令。</p>
<p>现在， 考虑这样一个情况， 如果我们对一个键执行 LLEN 命令， 那么服务器除了要确保执行命令的是列表键之外， 还需要根据键的值对象所使用的编码来选择正确的 LLEN 命令实现：</p>
<ul>
<li>如果列表对象的编码为 <code>ziplist</code> ， 那么说明列表对象的实现为压缩列表， 程序将使用 <code>ziplistLen</code> 函数来返回列表的长度；</li>
<li>如果列表对象的编码为 <code>linkedlist</code> ， 那么说明列表对象的实现为双端链表， 程序将使用 <code>listLength</code> 函数来返回双端链表的长度；</li>
</ul>
<p>借用面向对象方面的术语来说， 我们可以认为 LLEN 命令是多态（<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Polymorphism_(computer_science)">polymorphism</a>）的： 只要执行 LLEN 命令的是列表键， 那么无论值对象使用的是 <code>ziplist</code> 编码还是 <code>linkedlist</code> 编码， 命令都可以正常执行。</p>
<p>图 8-19 展示了 LLEN 命令从类型检查到根据编码选择实现函数的整个执行过程， 其他类型特定命令的执行过程也是类似的。</p>
<p>![58](redis 数据结构对象.assets&#x2F;69.png)</p>
<p>实际上， 我们可以将 DEL 、 EXPIRE 、 TYPE 等命令也称为多态命令， 因为无论输入的键是什么类型， 这些命令都可以正确地执行。</p>
<p>DEL 、 EXPIRE 等命令和 LLEN 等命令的区别在于， 前者是基于类型的多态 —— 一个命令可以同时用于处理多种不同类型的键， 而后者是基于编码的多态 —— 一个命令可以同时用于处理多种不同编码。</p>
<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个引用计数（<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Reference_counting">reference counting</a>）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收。</p>
<p>每个对象的引用计数信息由 <code>redisObject</code> 结构的 <code>refcount</code> 属性记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">    // 引用计数</span><br><span class="line">    int refcount;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>对象的引用计数信息会随着对象的使用状态而不断变化：</p>
<ul>
<li>在创建一个新对象时， 引用计数的值会被初始化为 <code>1</code> ；</li>
<li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li>
<li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li>
<li>当对象的引用计数值变为 <code>0</code> 时， 对象所占用的内存会被释放。</li>
</ul>
<p>表 8-12 列出了修改对象引用计数的 API ， 这些 API 分别用于增加、减少、重置对象的引用计数。</p>
<hr>
<p>表 8-12 修改对象引用计数的 API</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>incrRefCount</code></td>
<td>将对象的引用计数值增一。</td>
</tr>
<tr>
<td><code>decrRefCount</code></td>
<td>将对象的引用计数值减一， 当对象的引用计数值等于 <code>0</code> 时， 释放对象。</td>
</tr>
<tr>
<td><code>resetRefCount</code></td>
<td>将对象的引用计数值设置为 <code>0</code> ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。</td>
</tr>
</tbody></table>
<hr>
<p>对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。</p>
<p>作为例子， 以下代码展示了一个字符串对象从创建到释放的整个过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个字符串对象 s ，对象的引用计数为 1</span><br><span class="line">robj *s = createStringObject(...)</span><br><span class="line"></span><br><span class="line">// 对象 s 执行各种操作 ...</span><br><span class="line"></span><br><span class="line">// 将对象 s 的引用计数减一，使得对象的引用计数变为 0</span><br><span class="line">// 导致对象 s 被释放</span><br><span class="line">decrRefCount(s)</span><br></pre></td></tr></table></figure>

<p>其他不同类型的对象也会经历类似的过程。</p>
<h2 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h2><p>除了用于实现引用计数内存回收机制之外， 对象的引用计数属性还带有对象共享的作用。</p>
<p>举个例子， 假设键 A 创建了一个包含整数值 <code>100</code> 的字符串对象作为值对象， 如图 8-20 所示。</p>
<p>![73](redis 数据结构对象.assets&#x2F;70.png)</p>
<p>如果这时键 B 也要创建一个同样保存了整数值 <code>100</code> 的字符串对象作为值对象， 那么服务器有以下两种做法：</p>
<ol>
<li>为键 B 新创建一个包含整数值 <code>100</code> 的字符串对象；</li>
<li>让键 A 和键 B 共享同一个字符串对象；</li>
</ol>
<p>以上两种方法很明显是第二种方法更节约内存。</p>
<p>在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：</p>
<ol>
<li>将数据库键的值指针指向一个现有的值对象；</li>
<li>将被共享的值对象的引用计数增一。</li>
</ol>
<p>举个例子， 图 8-21 就展示了包含整数值 <code>100</code> 的字符串对象同时被键 A 和键 B 共享之后的样子， 可以看到， 除了对象的引用计数从之前的 <code>1</code> 变成了 <code>2</code> 之外， 其他属性都没有变化。</p>
<p>![73](redis 数据结构对象.assets&#x2F;71.png)</p>
<p>共享对象机制对于节约内存非常有帮助， 数据库中保存的相同值对象越多， 对象共享机制就能节约越多的内存。</p>
<p>比如说， 假设数据库中保存了整数值 <code>100</code> 的键不只有键 A 和键 B 两个， 而是有一百个， 那么服务器只需要用一个字符串对象的内存就可以保存原本需要使用一百个字符串对象的内存才能保存的数据。</p>
<p>目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 <code>0</code> 到 <code>9999</code> 的所有整数值， 当服务器需要用到值为 <code>0</code> 到 <code>9999</code> 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</p>
<p>注意</p>
<p>创建共享字符串对象的数量可以通过修改 <code>redis.h/REDIS_SHARED_INTEGERS</code> 常量来修改。</p>
<p>举个例子， 如果我们创建一个值为 <code>100</code> 的键 <code>A</code> ， 并使用 OBJECT REFCOUNT 命令查看键 <code>A</code> 的值对象的引用计数， 我们会发现值对象的引用计数为 <code>2</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET A 100</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT REFCOUNT A</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<p>引用这个值对象的两个程序分别是持有这个值对象的服务器程序， 以及共享这个值对象的键 <code>A</code> ， 如图 8-22 所示。</p>
<p>![73](redis 数据结构对象.assets&#x2F;72.png)</p>
<p>如果这时我们再创建一个值为 <code>100</code> 的键 <code>B</code> ， 那么键 <code>B</code> 也会指向包含整数值 <code>100</code> 的共享对象， 使得共享对象的引用计数值变为 <code>3</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET B 100</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT REFCOUNT A</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">redis&gt; OBJECT REFCOUNT B</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure>

<p>图 8-23 展示了共享值对象的三个程序。</p>
<p>![73](redis 数据结构对象.assets&#x2F;73.png)</p>
<p>另外， 这些共享对象不单单只有字符串键可以使用， 那些在数据结构中嵌套了字符串对象的对象（<code>linkedlist</code> 编码的列表对象、 <code>hashtable</code> 编码的哈希对象、 <code>hashtable</code> 编码的集合对象、以及 <code>zset</code> 编码的有序集合对象）都可以使用这些共享对象。</p>
<p>为什么 Redis 不共享包含字符串的对象？</p>
<p>当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</p>
<ul>
<li>如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</li>
<li>如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</li>
<li>如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。</li>
</ul>
<p>因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。</p>
<h2 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h2><p>除了前面介绍过的 <code>type</code> 、 <code>encoding</code> 、 <code>ptr</code> 和 <code>refcount</code> 四个属性之外， <code>redisObject</code> 结构包含的最后一个属性为 <code>lru</code> 属性， 该属性记录了对象最后一次被命令程序访问的时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 <code>lru</code> 时间计算得出的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">SET msg <span class="string">&quot;hello world&quot;</span></span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等待一小段时间</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT IDLETIME msg</span></span><br><span class="line">(integer) 20</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">等待一阵子</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT IDLETIME msg</span></span><br><span class="line">(integer) 180</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问 msg 键的值</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">GET msg</span></span><br><span class="line">&quot;hello world&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">键处于活跃状态，空转时长为 0</span></span><br><span class="line"><span class="meta prompt_">redis&gt; </span><span class="language-bash">OBJECT IDLETIME msg</span></span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>注意</p>
<p>OBJECT IDLETIME 命令的实现是特殊的， 这个命令在访问键的值对象时， 不会修改值对象的 <code>lru</code> 属性。</p>
<p>除了可以被 OBJECT IDLETIME 命令打印出来之外， 键的空转时长还有另外一项作用： 如果服务器打开了 <code>maxmemory</code> 选项， 并且服务器用于回收内存的算法为 <code>volatile-lru</code> 或者 <code>allkeys-lru</code> ， 那么当服务器占用的内存数超过了 <code>maxmemory</code> 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Redis 数据库中的每个键值对的键和值都是一个对象。</li>
<li>Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。</li>
<li>Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。</li>
<li>Redis 会共享值为 <code>0</code> 到 <code>9999</code> 的字符串对象。</li>
<li>对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">John Doe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/07/25/redis-data-construction-object/">http://example.com/2022/07/25/redis-data-construction-object/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/25/test/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">test</div></div></a></div><div class="next-post pull-right"><a href="/2022/07/24/newpapername/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">newpapername</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">John Doe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SDS-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.</span> <span class="toc-text">SDS  简单动态字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Redis%E6%B2%A1%E6%9C%89%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA%EF%BC%8C%E8%80%8C%E6%98%AF%E8%87%AA%E5%B7%B1%E6%9E%84%E5%BB%BASDS%EF%BC%8C%E5%B9%B6%E4%BD%9C%E4%B8%BARedis%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">为什么Redis没有直接使用C语言传统的字符串表示，而是自己构建SDS，并作为Redis的默认字符串表示？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SDS-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.</span> <span class="toc-text">SDS 的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SDS%E4%B8%8EC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">SDS与C字符串的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B8%B8%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 常数复杂度获取字符串长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9D%9C%E7%BB%9D%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 杜绝缓冲区溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%8F%E5%B0%91%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8D%E5%88%86%E9%85%8D%E6%AC%A1%E6%95%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 减少修改字符串时带来的内存重分配次数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E7%A9%BA%E9%97%B4%E9%A2%84%E5%88%86%E9%85%8D"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">1）空间预分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%83%B0%E6%80%A7%E7%A9%BA%E9%97%B4%E9%87%8A%E6%94%BE"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2）惰性空间释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. 二进制安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%BC%E5%AE%B9%E9%83%A8%E5%88%86C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. 兼容部分C字符串函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SDS-API"><span class="toc-number">1.4.</span> <span class="toc-text">SDS API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">链表和链表节点的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9%E7%9A%84API"><span class="toc-number">2.2.</span> <span class="toc-text">链表和链表节点的API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E5%85%B8"><span class="toc-number">3.</span> <span class="toc-text">字典</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.</span> <span class="toc-text">哈希表定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">哈希表节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8-1"><span class="toc-number">3.3.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">哈希算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%94%AE%E5%86%B2%E7%AA%81"><span class="toc-number">3.5.</span> <span class="toc-text">解决键冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rehash"><span class="toc-number">3.6.</span> <span class="toc-text">rehash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%89%A9%E5%B1%95%E4%B8%8E%E6%94%B6%E7%BC%A9"><span class="toc-number">3.7.</span> <span class="toc-text">哈希表的扩展与收缩</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8F-rehash"><span class="toc-number">3.8.</span> <span class="toc-text">渐进式 rehash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8F-rehash-%E6%89%A7%E8%A1%8C%E6%9C%9F%E9%97%B4%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">3.9.</span> <span class="toc-text">渐进式 rehash 执行期间的哈希表操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8-API"><span class="toc-number">3.10.</span> <span class="toc-text">字典 API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">跳跃表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.1.</span> <span class="toc-text">跳跃表的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E8%A1%A8%E8%8A%82%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">跳跃表节点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B1%82"><span class="toc-number">4.2.1.</span> <span class="toc-text">1. 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%89%8D%E8%BF%9B%E6%8C%87%E9%92%88"><span class="toc-number">4.2.2.</span> <span class="toc-text">2. 前进指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%A8%E5%BA%A6"><span class="toc-number">4.2.3.</span> <span class="toc-text">3. 跨度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%90%8E%E9%80%80%E6%8C%87%E9%92%88"><span class="toc-number">4.2.4.</span> <span class="toc-text">4. 后退指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%86%E5%80%BC%E5%92%8C%E6%88%90%E5%91%98"><span class="toc-number">4.2.5.</span> <span class="toc-text">5. 分值和成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E8%A1%A8-1"><span class="toc-number">4.3.</span> <span class="toc-text">跳跃表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E8%A1%A8API"><span class="toc-number">4.4.</span> <span class="toc-text">跳跃表API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="toc-number">5.</span> <span class="toc-text">整数集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.</span> <span class="toc-text">整数集合的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7"><span class="toc-number">5.2.</span> <span class="toc-text">升级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%87%E7%BA%A7%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">5.3.</span> <span class="toc-text">升级的好处</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8D%87%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="toc-number">5.3.1.</span> <span class="toc-text">提升灵活性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98"><span class="toc-number">5.3.2.</span> <span class="toc-text">节约内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%8D%E7%BA%A7"><span class="toc-number">5.4.</span> <span class="toc-text">降级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88-API"><span class="toc-number">5.5.</span> <span class="toc-text">整数集合 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">5.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-number">6.</span> <span class="toc-text">压缩列表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%9A%84%E6%9E%84%E6%88%90"><span class="toc-number">6.1.</span> <span class="toc-text">压缩列表的构成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0"><span class="toc-number">6.2.</span> <span class="toc-text">连锁更新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8-API"><span class="toc-number">6.3.</span> <span class="toc-text">压缩列表 API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">6.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%BC%96%E7%A0%81"><span class="toc-number">7.1.</span> <span class="toc-text">对象的类型与编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.1.</span> <span class="toc-text">1. 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BC%96%E7%A0%81%E5%92%8C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.1.2.</span> <span class="toc-text">2. 编码和底层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.2.</span> <span class="toc-text">字符串对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.2.1.</span> <span class="toc-text">编码的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.2.</span> <span class="toc-text">字符串命令的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.3.</span> <span class="toc-text">列表对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.3.1.</span> <span class="toc-text">编码转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.2.</span> <span class="toc-text">列表命令的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.4.</span> <span class="toc-text">哈希对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">7.4.1.</span> <span class="toc-text">编码转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.4.2.</span> <span class="toc-text">哈希命令的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.5.</span> <span class="toc-text">集合对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E7%9A%84%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">7.5.1.</span> <span class="toc-text">编码的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.5.2.</span> <span class="toc-text">集合命令的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.6.</span> <span class="toc-text">有序集合对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E7%9A%84%E8%BD%AC%E6%8D%A2-2"><span class="toc-number">7.6.1.</span> <span class="toc-text">编码的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.6.2.</span> <span class="toc-text">有序集合命令的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E4%B8%8E%E5%91%BD%E4%BB%A4%E5%A4%9A%E6%80%81"><span class="toc-number">7.7.</span> <span class="toc-text">类型检查与命令多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.7.1.</span> <span class="toc-text">类型检查的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.8.</span> <span class="toc-text">多态命令的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-number">7.9.</span> <span class="toc-text">内存回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB"><span class="toc-number">7.10.</span> <span class="toc-text">对象共享</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A9%BA%E8%BD%AC%E6%97%B6%E9%95%BF"><span class="toc-number">7.11.</span> <span class="toc-text">对象的空转时长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">7.12.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/16/article-title/" title="article title"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="article title"/></a><div class="content"><a class="title" href="/2022/09/16/article-title/" title="article title">article title</a><time datetime="2022-09-16T05:06:50.000Z" title="Created 2022-09-16 13:06:50">2022-09-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/16/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86/" title="JVM字节码指令集概述"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JVM字节码指令集概述"/></a><div class="content"><a class="title" href="/2022/09/16/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86/" title="JVM字节码指令集概述">JVM字节码指令集概述</a><time datetime="2022-09-16T05:06:50.000Z" title="Created 2022-09-16 13:06:50">2022-09-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/25/test/" title="test"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="test"/></a><div class="content"><a class="title" href="/2022/07/25/test/" title="test">test</a><time datetime="2022-07-25T10:38:07.000Z" title="Created 2022-07-25 18:38:07">2022-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/25/redis-data-construction-object/" title="redis_data_construction_object"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis_data_construction_object"/></a><div class="content"><a class="title" href="/2022/07/25/redis-data-construction-object/" title="redis_data_construction_object">redis_data_construction_object</a><time datetime="2022-07-25T10:22:48.000Z" title="Created 2022-07-25 18:22:48">2022-07-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/24/newpapername/" title="newpapername"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="newpapername"/></a><div class="content"><a class="title" href="/2022/07/24/newpapername/" title="newpapername">newpapername</a><time datetime="2022-07-24T12:28:21.000Z" title="Created 2022-07-24 20:28:21">2022-07-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By John Doe</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>